//! Hook 只能在最顶层使用，不能在循环、条件或嵌套函数中调用，因为同一Hook可以多次使用是根据调用顺序来确定一一对应相关state或effect等内容的，初次渲染就决定了后续每次重渲染时hook调用顺序也要一致，

//! Hook 在 class 组件中无效，只适用于函数组件或自定义hook（除此外的普通JS函数中也不能使用）

//! Hook 是 React 16.8+ 的新增特性，可以在函数组件中使用 state 以及其他的 React 特性，让函数组件也可成为有状态组件

//! 以下两个错误边界处理生命周期方法任意定义一个(或两个)，则该组件就变成一个错误边界组件，可捕获子组件内的JS错误(自身的不行)而进行降级处理

//! 以下两个错误边界处理生命周期方法任意定义一个(或两个)，则该组件就变成一个错误边界组件，可捕获子组件内的JS错误而进行降级处理

//! 传入`setState()`方法的数据不是直接覆盖整个原state对象，而是与原state对象下的一级属性进行浅合并，所以传入的对象或是函数返回的对象可以只包含当前需要改变的那些状态

//! 可以看做是componentDidMount、componentDidUpdate、componentWillUnmount 这三个生命周期函数的组合

//! 同一组件中可以多次调用 useState 创建不同state数据项(就像class组件在state属性下不同数据项)，之间互不影响

//! 多个`Context.Provider`可嵌套使用，以发布多个context，此时也需要多个`Context.Consumer`嵌套使最底层组件同时订阅多个context

//! 应确保确实无任何依赖数据(否则实际用到了却未添加进该依赖表的数据将始终是最初的旧数据)，故只在 useEffect 中用到的函数最好都放在 useEffect 中去声明(就近原则更容易注意到是否有依赖数据)

//! 当前状态依赖于其上一个状态值时，可以使用其函数参数形式，使得每次正确获取到上一次的状态值

//! 故要求每个声明的hook在每次渲染时要么都会调用，要么都不会调用，使得每次所有hook的执行顺序都一致，而不允许某hook这次调用了下次可能没调用，

//! 清除操作每次渲染后都会执行是因为上面提到每次渲染后会重新创建effect函数进行替换，所以要清除上一次的副作用操作，这样就不会与新创建的副作用操作重复(或只能唯一存在时却未清除旧数据关联的绑定)，并再同步绑定此次新的清除函数

//! 若一个错误边界无法渲染错误信息，则错误会冒泡至其最近的上层错误边界(若存在，v16+开始任何未被错误边界捕获的错误将导致整个React组件树被卸载)，这也类似于JS中的`catch{}`工作机制

//! 若作为错误边界处理组件，内部组件出错时进行UI降级

//! 若出现上面提到的不允许的方式，则调用顺序就不固定，也就造成Hook与其关联的state或effect对应错误（像条件语句就会导致条件中的hook只会在满足条件时调用，而不是每次都会调用到）,

//! 若当前底层组件通过该context未匹配到上层使用该相同context的Provider提供者，无法读取其数据，此时就会使用该context声明时传入的defaultValue默认值

//! 若换成如下依赖外部`count`的形式，则首先需要在依赖列表中添加`count`(易遗忘导致bug，一直是初始值)，然后将使得每次`count`更新都会导致这里的effect函数执行

//! 若要用到上面提到的循环、条件或嵌套函数，可以将其逻辑转移到 hook 的内部去

//! 若返回一个函数(可选)，则该返回的函数将在 componentWillUnmount 时调用，用于清除相关副作用操作(一般用于需要成对的操作，像事件绑定与移除，消息订阅与取消等)，这里的清除操作实际每次渲染后都会执行而不只是组件卸载的时候

//! 该`contextType`静态属性只有class类声明的组件可使用，函数组件不可用，函数组件可以使用`useContext(MyContext)`hook钩子进行绑定和获取先关context

//! 该方法内只返回要更新的`state`数据对象，方法内部会自己去更新`state`

//! 避免每次`Provider`重渲染时，即使`value`值未变化，也会使其内部订阅该context的子孙组件都重渲染(因每次`value`的对象值都相当于是新声明的，与原对象不是同一个地址，被认为数据已变化)

//! 鉴于这两个错误边界声明周期只能在class类组件中定义，因此也就只有class类组件才可以成为错误边界组件，而函数组件不行

//! 须注意上面两种方式绑定的组件func都是函数式组件，且其都是一个函数声明或是函数引用，而不是一个函数组件标签(react元素)，不同于`react-router-dom`中`Route`组件上函数和元素都可

//! 须注意，若`value`属性指定的值是一个对象，则应该将该对象提升到`Provider`标签外存储或组件的`state`中，这里只引用，而不是直接将对象声明在`value`属性中，

//! 默认不传第二个参数则表示依赖所有导致渲染更新的数据，为空数组时表示不依赖任何数据，近似只在 componentDidMount 和 componentWillUnmount 时执行一次

//!若在使用babel转换class语法，这可以使用`static`这个类属性初始化contextType，否则就只能在类声明完后使用`MyComponent.contextType = ThemeContext`的方式初始化contextType
