<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVG</title>
    <link rel="stylesheet" href="../plugins/google-code-prettify/skins/sons-of-obsidian.css">
    <style>
        *{-webkit-box-sizing: border-box;-moz-box-sizing: border-box;-ms-box-sizing:border-box;-o-box-sizing:border-box;box-sizing: border-box;}
        body,h4,p,ul,pre {margin: 0;}
        ul{padding: 0;}
        .fl {float: left;}
        .fz-30 {font-size: 30px;}
        .mgt-10 {margin-top: 10px;}
        .mgl-30 { margin-left: 30px;}
        .clearfix{*zoom:1;}
        .clearfix:before {content:"";display:table;}
        .clearfix:after {clear:both;content:' ';display:block;font-size:0;line-height:0;visibility:hidden;height:0;}
        .box-wrap{height: 300px;border: 1px solid #dadada;}
        .code-format {display: block;white-space: pre;font-family: monospace;overflow: auto;}
        .left-box,
        .right-box {float: left;width: 75%;height: 100%;overflow: auto;}
        .right-box {padding: 10px 0 !important;}
        .left-box {position: relative;border-right: 1px solid #dadada; width: 25%;}
        .left-box svg {display: block;width: 100%;height: 100%;}
        .catalogue-list {position: -webkit-sticky;position: sticky;top: 0;z-index: 9;background: #ffffff;}
        h4,p,pre {padding-left: 10px;}
        img {max-width: 100%;vertical-align: top;background: #ffffff;}
        a { color: #0000ff !important;}
        .to-top {position: fixed;width: 50px;height: 50px;line-height: 50px;right: 30px;bottom: 20px;border-radius: 100%;text-align: center;background: #bbb;color: #ffffff!important;text-decoration: none;font-weight: bold;}
        .to-top:hover {background: #888888;}
        pre {max-width: 100%;overflow: auto;}
        .transition * { transition: all 1s; }
    </style>
</head>
<body>
<h3>扩展：<a target="_blank" href="SVG奇思妙想.html">SVG奇思妙想</a></h3>
<a href="#" class="to-top">Top</a>
<p class="catalogue-list">目录：
    <a href="#svg元素">svg元素</a>
    <a class="mgl-30" href="#viewBox可视窗口">viewBox可视窗口</a>
    <a class="mgl-30" href="#preserveAspectRatio">preserveAspectRatio</a>
    <a class="mgl-30" href="#内置属性">内置属性</a>
    <a class="mgl-30" href="#矩形">矩形-rect</a>
    <a class="mgl-30" href="#圆">圆-circle</a>
    <a class="mgl-30" href="#椭圆">椭圆-ellipse</a>
    <a class="mgl-30" href="#直线">直线-line</a>
    <a class="mgl-30" href="#折线">折线-polyline</a>
    <a class="mgl-30" href="#多边形">多边形-polygon</a>
    <a class="mgl-30" href="#路径">路径-path</a>
    <a class="mgl-30" href="#文本">文本和超链接-text/a</a>
    <a class="mgl-30" href="#渐变">渐变-linearGradient/radialGradient</a>
    <a class="mgl-30" href="#定义和分组">定义、分组和引用-defs/symbol/g/use</a>
    <a class="mgl-30" href="#裁剪">裁剪-clipPath</a>
    <a class="mgl-30" href="#图片">图片-image和线段始末标记-marker</a>
    <a class="mgl-30" href="#填充">填充(笔刷)-pattern</a>
    <a class="mgl-30" href="#滤镜">滤镜(模糊/投影)-filter</a>
    <a class="mgl-30" href="#遮罩">遮罩/蒙版-mask</a>
    <a class="mgl-30" href="#变换">变换-transform</a>
    <a class="mgl-30" href="#动画">SVG动画</a>
    <a class="mgl-30" href="#变形动画">变形动画</a>
    <a class="mgl-30" href="#路径动画">运动(路径)动画</a>
    <a class="mgl-30" href="#线条动画">线条动画</a>
</p>
<p>参考：
  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode">blend-mode颜色叠加时的混合模式</a>
</p>
<p class="code-format"><b>viewport</b>为svg物理窗口，即svg的实际大小(默认大小，或通过width、height属性，或css样式设置的大小)。
    viewport与viewBox的关系就像手机查看一张照片(假设照片是一张拼接了很多小照片的大照片)时屏幕与里面一张小照片的关系，
    屏幕就是viewport，大小是确定的；屏幕中的内容就是整个绘图空间，大小可无限大，只是没在viewport可视区中的部分就看不到而已；而我们想要着重查看的照片上的某个区域就是viewBox(某张小照片)，
    着重查看的区域宽高比例不一定与屏幕宽高比例一样(很多时候都不一样)，这时将这个小照片部分放大到某边与屏幕对应边一样大，这时根据preserveAspectRatio的设定不动表现就有所不同。
    可能整个小照片都能看到且屏幕可能还有剩余区域能看到部分其他小照片；也可能一边撑满屏幕而另一边已经超出屏幕，此时该小照片都看不完整，就更不用说该小照片以外的部分了。
    preserveAspectRatio属性中第二个参数的值表现就类似于background-size的表现，meet值类似contain将内容最大化能在容器中放下，slice值类似cover将内容撑满整个容器。
    不管是meet还是slice，选定区域都是等比例缩放的，但preserveAspectRatio属性表示对齐方式的第一个参数也会影响viewBox左上角在viewport中的对齐位置。
    <b style="color: orange;">若将preserveAspectRatio设置为`none`，则宽高比就会进行拉伸，类似`background-size:100% 100%`的效果，此时`viewBox`中的值可以看作是viewport的比例尺。</b>
    换种理解方式也就是从画布中(注意是画布中，不是viewport中)按`viewBox`截取一块再按`preserveAspectRatio`的设定模式放大或缩小到适合`viewport`的大小并与其对齐，
    `viewBox`的目的是将画布中想重点查看或想实际看到的区域放大或缩小到`viewport`物理窗口中，放大就是将画布上一小块区域扩展到整个屏幕重点查看，而缩小就是能将画布上屏幕外的内容也收缩到屏幕内查看。
</p>
<ol>
  <li><b>注意：</b>SVG2.0中已删除表示链接地址的`xlink:href`属性，而直接使用`href`属性</li>
</ol>
<ul>

    <!--================================================== svg元素 ==================================================-->
<li>
<h4 id="svg元素">svg元素 <a target="_blank" class="mgl-30" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">svg元素列表参考</a></h4>
<div class="box-wrap clearfix" style="height: 180px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg">
        <rect x="10" y="10" width="50" height="50" rx="10" ry="10" stroke="red" fill="none"/>
        <circle cx="95" cy="35" r="25" stroke="red" fill="none"/>
        <ellipse cx="180" cy="35" rx="50" ry="25" stroke="red" fill="none"/>
        <line x1="10" y1="70" x2="60" y2="120" stroke-width="3" stroke="red"/>
        <polyline points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="none"/>
        <polygon points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="yellow" transform="translate(70,0)"/>
    </svg>
</div>
<pre class="right-box">
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" baseProfile="full" width="100%" height="100%">
        图形标签...
    </svg>
    xmlns="http://www.w3.org/2000/svg" 为svg命名空间
    version="1.1" 版本
    baseProfile="full" 特性描述了作者认为正确渲染内容所需要的最小的SVG语言概述，四个可选值：none(无，默认)|full(适用于PC)|basic(适用于PAD)|tiny(适用于手机)
    width="宽度" 可选，可带单位，不带单位则默认为px，优先级低于css样式，svg内部子元素上的尺寸属性也可带单位(若svg上设置了viewBox则不能带单位)
    height="高度" 可选，可带单位，不带单位则默认为px，优先级低于css样式，svg内部子元素上的尺寸属性也可带单位(若svg上设置了viewBox则不能带单位)
    svg元素宽高代表了其物理窗口 viewport 大小，没有任何宽高设置时，svg与其它替换元素(如iframe)一样默认宽高为300*150
</pre>
</div>
</li>

    <!--=============================================== viewBox可视窗口 ===============================================-->
<li>
<h4 id="viewBox可视窗口">viewBox可视窗口 <a target="_blank" class="mgl-30" href="http://www.zhangxinxu.com/wordpress/2014/08/svg-viewport-viewbox-preserveaspectratio/">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 140px;">
<div class="left-box">
    <svg viewBox="0 0 80 80" preserveAspectRatio="xMinYMin meet">
        <rect x="10" y="10" width="50" height="50" rx="10" ry="10" stroke="red" fill="none"/>
        <circle cx="95" cy="35" r="25" stroke="red" fill="none"/>
        <ellipse cx="180" cy="35" rx="50" ry="25" stroke="red" fill="none"/>
        <line x1="10" y1="70" x2="60" y2="120" stroke-width="3" stroke="red"/>
        <polyline points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="none"/>
        <polygon points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="yellow" transform="translate(70,0)"/>
    </svg>
</div>
<pre class="right-box">
    <svg viewBox="0 0 80 80" preserveAspectRatio="xMinYMin meet">
        viewBox中的偏移设置时多设置0.5可使线条更加锐利纤细(浏览器一像素原理)
        当 x = -width/2，y = -height/2，且preserveAspectRatio为默认的"xMinYMin meet"时，可以将默认左上角的原点拉动到viewport的正中间，这样更有利于计算坐标，特别是绘制对称性图形时。
    </svg>
    viewBox="x y width height" 设置可视窗口(重点查看的画布区域)，值分别为“起点横坐标，起点纵坐标，窗口宽度，窗口高度”，一般前两个值都是0(即从左上角默认原点开始)，不设置viewBox时，默认就是viewport窗口。
    viewBox就像截图时我们选中的区域(只不过可截取的范围是整个画布而不仅仅是viewport可视区)，截取下的部分再等比例缩放使至少一边撑满整个viewport(至于是缩放到完全包含在viewport中还是完全铺满超出部分被裁剪就决定于preserveAspectRatio属性)
    并不是说只显示viewBox设置的区域，而是以该区域缩放后的大小来根据模式适应viewport，实际缩放的还是整个viewport中的内容，只是整个内容缩放后可能有的内容已经超出viewport而不可见，可能将viewport外的内容缩小拉回了可视区内(viewBox的范围超出viewport时)
    preserveAspectRatio不指定时默认为"xMinYMin meet"，这里设置为"xMinYMin meet"方便查看viewBox区域。
</pre>
</div>
</li>

    <!--============================ preserveAspectRatio对齐和缩放平铺模式(作用于viewBox属性) ============================-->
<li>
<h4 id="preserveAspectRatio">preserveAspectRatio对齐和缩放平铺模式(作用于viewBox属性) <a target="_blank" class="mgl-30" href="http://www.zhangxinxu.com/wordpress/2014/08/svg-viewport-viewbox-preserveaspectratio/">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 360px;">
<div class="left-box">
    <svg viewBox="0 0 160 80" preserveAspectRatio="xMidYMid meet">
        <rect x="10" y="10" width="50" height="50" rx="10" ry="10" stroke="red" fill="none"/>
        <circle cx="95" cy="35" r="25" stroke="red" fill="none"/>
        <ellipse cx="180" cy="35" rx="50" ry="25" stroke="red" fill="none"/>
        <line x1="10" y1="70" x2="60" y2="120" stroke-width="3" stroke="red"/>
        <polyline points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="none"/>
        <polygon points="70 70, 100 120, 130 80, 100 70" stroke="red" fill="yellow" transform="translate(70,0)"/>
    </svg>
</div>
<pre class="right-box">
    <svg viewBox="0 0 160 80" preserveAspectRatio="xMidYMid meet">
        图形标签...
    </svg>
    preserveAspectRatio="align [meet|slice]" 规定viewBox可视窗口在viewport中的对齐和缩放平铺方式，align为对齐方式，第二个参数为包含撑满还是平铺撑满模式(类似background-size属性的contain与cover关系)，默认值为"xMidYMid meet"；
    除此之外，preserveAspectRatio还有个单独值“none”，表示viewBox的宽高都拉伸为viewport的宽高，这可能导致图形变形；
    rateX = viewport_width/viewBox_width；rateY = viewport_height/viewBox_height；rateX、rateY分别为x方向和y方向的缩放比例
    meet：宽高都按rateX、rateY中较小的缩放
    slice：宽高都按rateX、rateY中较大的缩放
    none：宽高分别按rateX、rateY缩放
    align由x和y两个方向合并而成，且其各有三个值选择：
    x方向：                          y方向(注意Y大写)：
    xMin                            YMin
    xMid                            YMid
    xMax                            YMax
    Min、Mid、Max分别代表了盒子的左中右(上中下)几个位置， x、y方向值进行组合就得到align值，如：xMinYMin，合在一点就是盒子的四角和边中点及盒子中心共9个点
    这种对齐方式与background-position的百分比值很相似(0%、50%、100%)，是两个盒子的相同位置对齐，如xMinYMin，就是viewBox的左上角与viewport的左上角对齐
    <img src="../知识点截图/svg/svg之viewport和viewbox对齐.png" title="svg之viewport和viewbox对齐xMidYMid"><img src="../知识点截图/svg/svg之preserveAspectRatio中align代表的位置.png" title="svg之preserveAspectRatio中align代表的位置">
</pre>
</div>
</li>

    <!--======================================== 内置图形的html属性(或css样式)  ========================================-->
<li>
<h4 id="内置属性">内置图形的html属性(或css样式) <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 360px;">
<div class="left-box">
    <svg style="height: 100px;">
        <rect x="10" y="10" width="100" height="50"
              stroke="red"
              stroke-width="5"
              stroke-opacity="0.8"
              stroke-dasharray="10,5"
              stroke-linecap="butt"
              fill="green"
              fill-opacity="0.7"
              transform="translate(30,10)" />
    </svg>
    <img src="../知识点截图/canvas/canvas之封闭区域非零环绕原则.png" title="【非零环绕原则】区域内向外引一条射线与绘图路径边界相交，取一个(顺时针或者逆时针)方向为1，则反方向为-1，所有相交路径相加为非0则表示内部，否则为内部。【奇偶环绕原则】不管相交路径的方向，只管相交路径的数量，奇数表示内部，偶数表示外部" width="100%">
</div>
<pre class="right-box">
    <svg>
        &lt;rect x="10" y="10" width="100" height="50"
            stroke="描边颜色"
            stroke-width="描边宽度"
            stroke-opacity="描边透明度，取值0~1"
            stroke-dasharray="创建虚线描边，值为逗号分隔的数字(可多个)，依次循环表示连续点和间断点的宽度，一个数字时表示连续和间断宽度一样，如:'10,5,5,10'表示虚线按'连续10个单位，间断5个单位，连续5个单位，间断10个单位'这样的片段重复"
            stroke-dashoffset="设置上面dasharray重复单元开始的位置(注意是dasharray上开始重复的位置，而不是svg路径上开始重复的位置)，可以是数字或百分比，百分比值是相对于SVG的viewport；该属性结合上面的stroke-dasharray可实现线条的运动"
            stroke-linecap="线冒形状，同canvas中的lineCap"
            stroke-linejoin="线段连接处形状，同canvas中的lineJoin，默认为miter"
            stroke-miterlimit="拐点宽度限制长度，同canvas中的miterLimit，在linejoin为miter时有效"
            fill="填充颜色，默认为黑色，可以设为none表示没有填充"
            fill-opacity="填充透明度"
            fill-rule="填充规则，默认为非零环绕原则`nonzero`，另有奇偶环绕原则`evenodd`"
            transform="变换"
            filter="滤镜" />
    </svg>
    这些属性不仅可以当做html标签上的属性，也可以当做css属性使用，放在style中，此时等号就要换为冒号，如：
    &lt;rect x="50" y="20" width="150" height="150" style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9"/>
</pre>
</div>
</li>

    <!--================================================= 矩形-rect =================================================-->
<li>
<h4 id="矩形">矩形-rect <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <rect x="50" y="10" width="100" height="50" rx="10" ry="10" stroke="red" fill="none"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <rect x="50" y="10" width="100" height="50" rx="10" ry="10" stroke="red" fill="none"/>
        <rect x="绘制位置x坐标" y="绘制位置y坐标" width="宽度" height="高度" rx="水平圆角大小" ry="垂直圆角大小" />
    </svg>
    关键属性为：x、y、width、height；圆角只设置一个方向时，另一个默认相同
</pre>
</div>
</li>

    <!--================================================= 圆-circle =================================================-->
<li>
<h4 id="圆">圆-circle <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <circle cx="100" cy="50" r="40" stroke="red" fill="none"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <circle cx="100" cy="50" r="40" stroke="red" fill="none"/>
        <circle cx="圆心x坐标" cy="圆心y坐标" r="半径" />
    </svg>
    关键属性为：cx、cy、r
</pre>
</div>
</li>

    <!--================================================ 椭圆-ellipse ================================================-->
<li>
<h4 id="椭圆">椭圆-ellipse <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <ellipse cx="100" cy="50" rx="50" ry="25" stroke="red" fill="none"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <ellipse cx="100" cy="50" rx="50" ry="25" stroke="red" fill="none"/>
        <ellipse cx="椭圆中心x坐标" cy="椭圆中心y坐标" rx="椭圆水平半径" ry="椭圆垂直半径" />
    </svg>
    关键属性为：cx、cy、rx、ry
</pre>
</div>
</li>

    <!--================================================= 直线-line =================================================-->
<li>
<h4 id="直线">直线-line <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <line x1="50" y1="20" x2="150" y2="80" stroke="red"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <line x1="50" y1="20" x2="150" y2="80" stroke="red"/>
        <line x1="起点x坐标" y1="起点y坐标" x2="终点x坐标" y2="终点y坐标" />
    </svg>
    关键属性为：x1、y1、x2、y2
</pre>
</div>
</li>

    <!--=============================================== 折线-polyline ===============================================-->
<li>
<h4 id="折线">折线-polyline <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <polyline points="70 20, 100 70, 130 30, 100 20" stroke="red" fill="none"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <polyline points="70 20, 100 70, 130 30, 100 20" stroke="red" fill="none"/>
        <polyline points="多个拐点坐标(x1 y1, x2 y2, x3 y3, ...)" />
    </svg>
    关键属性为：points，所有坐标可用空格隔开也可用逗号隔开
</pre>
</div>
</li>

    <!--=============================================== 多边形-polygon ===============================================-->
<li>
<h4 id="多边形">多边形-polygon <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 110px;">
<div class="left-box">
    <svg>
        <polygon points="70 20, 100 70, 130 30, 100 20" stroke="red" fill="yellow"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <polygon points="70 20, 100 70, 130 30, 100 20" stroke="red" fill="yellow"/>
        <polygon points="x1 y1, x2 y2, x3 y3, ..." />
    </svg>
    关键属性为：points，points参数与polyline一样，区别在于polygon的首尾两点会自动连接形成封闭图形
</pre>
</div>
</li>

    <!--================================================= 路径-path =================================================-->
<li>
<h4 id="路径">路径-path <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 360px;">
<div class="left-box">
    <svg>
        <path d="M70 20, L100 70, L130 30, L100 20" stroke="red" fill="yellow"/>
    </svg>
</div>
<pre class="right-box">
    <svg>
        <path d="M70 20, L100 70, L130 30, L100 20" stroke="red" fill="yellow"/>
    </svg>
    关键属性为：d

<img src="../知识点截图/svg/svg之path路径d属性指令.png" title="svg之path路径d属性指令">
    A rx ry x-deg large-arc sweep-flag x y
    椭圆弧中rx ry表示x轴半径和y轴半径，x-deg表示x轴旋转角度，large-arc表示大于180度还是小于180度的弧段，即长弧段与短弧段(0为小，1为大)，sweep-flag表示弧线方向(0为沿逆时针，1为沿顺时针)，x y为最终坐标
</pre>
</div>
</li>

    <!--================================================= 文本-text/tspan/textPath/a =================================================-->
<li>
<h4 id="文本">文本和超链接-text/tspan/textPath/a <a target="_blank" class="mgl-30" href="http://www.runoob.com/svg/svg-text.html">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 200px;">
<div class="left-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <path id="path1" d="M100,20 a1,1 0 0,0 100,0 l-50,150 l150,0" />
        </defs>
        <text x="10" y="10" dx="0" dy="10" fill="red">SVG文本</text>
        <text x="10" y="100" style="fill:red;">
            <textPath xlink:href="#path1">SVG文字按路径排列，若路径长度不够，则剩余的文字将不会被显示</textPath>
        </text>
        <text x="10" y="20" style="fill:red;" transform="translate(0,30)">文字分段：
            <tspan x="10" y="45">第一段</tspan>
            <tspan x="10" y="70">第二段</tspan>
        </text>
        <a xlink:href="http://www.runoob.com/svg/svg-text.html" target="_blank">
            <text x="10" y="130" fill="blue">文本链接</text>
        </a>
    </svg>
</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--xmlns:xlink="http://www.w3.org/1999/xlink" 为链接命名空间，若svg内有标签用到 xlink:href="" 属性，就应该在 svg 标签上加上该命名空间-->

        <!--预定义一条路径，通过id调用-->
        <defs>
            <path id="path1" d="M100,20 a1,1 0 0,0 100,0" />
        </defs>

        <!--普通文本-->
        <text x="50%" y="10" dx="10" dy="10" fill="red" text-anchor="middle">SVG文本</text>
        <text x="起点x坐标(注意会受text-anchor属性影响)" y="起点y坐标" dx="x方向偏移量" dy="y方向偏移量" text-anchor="设置的参考点(x,y)坐标相对文本的位置，有值 start | middle | end | inherit，分别表示文字开始处、中间、结尾处、继承(注意是整段文字)，默认start">SVG文本</text>

        <!--SVG文字按路径排列 textPath-->
        <text x="10" y="100" style="fill:red;">
            <textPath xlink:href="#path1">文本</textPath>
            <textPath xlink:href="预定义的路径id">若路径长度不够，则剩余的文字将不会被显示</textPath>
        </text>

        <!--文字分段-->
        <text x="10" y="20" style="fill:red;" transform="translate(0,30)">文字分段：
            <tspan x="10" y="45">第一段</tspan>
            <tspan x="10" y="70">第二段</tspan>
        </text>

        <!--文本链接，使用 a 标签，a标签中也可以放置其他图形-->
        <a xlink:href="http://www.runoob.com/svg/svg-text.html(链接地址)" target="_blank">
            <text x="10" y="130" fill="blue">文本链接</text>
        </a>
    </svg>
    关键属性为：x、y，须注意：x为文字最左端位置，而y并非文字顶端，而是文字基线baseline的位置，a标签内科放置任意内容(跟html中类似)
</pre>
</div>
</li>

    <!--===================================== 渐变-linearGradient/radialGradient =====================================-->
<li>
<h4 id="渐变">渐变-linearGradient/radialGradient <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 360px;">
<div class="left-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <linearGradient id="linearGradient" x1="0%" y1="0%" x2="100%" y2="0%">  <!--x1,y1 x2,y2用来定义径向渐变的方向，此处为向右-->
                <stop offset="0%" stop-color="blue" />
                <stop offset="100%" stop-color="red" />
            </linearGradient>
            <radialGradient id="radialGradient">
                <stop offset="10%" stop-color="red" />
                <stop offset="60%" stop-color="orange" />
                <stop offset="100%" stop-color="rgba(255,255,0,0.3)" />
            </radialGradient>
        </defs>
        <text x="10" y="30" fill="red">线性渐变 linearGradient</text>
        <rect fill="url(#linearGradient)" x="10" y="40" width="200" height="100"/>
        <text x="10" y="170" fill="red">径向渐变 radialGradient</text>
        <circle cx="100" cy="230" r="50" fill="url(#radialGradient)"></circle>
    </svg>
</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--预定义-->
        <defs>
            <!--线性渐变，通过id引用-->
            <linearGradient id="linearGradient" x1="0%" y1="0%" x2="100%" y2="0%">  <!-- x1,y1 x2,y2用来定义径向渐变的方向，可为小数或百分比，此处为向右 -->
                <stop offset="0%" stop-color="blue" stop-opacity="0.9" />  <!-- offset指明渐变位置(可为小数或百分比)，stop-color属性指定该位置渐变色，stop-opacity属性可指定该位置透明度 -->
                <stop offset="100%" stop-color="red" /> <!-- 起始位置不一定为0，结束位置也不一定为100%，设定的两端到图形边界位置为对应起始或结束位置的纯色 -->
            </linearGradient>
            <!--径向渐变，通过id引用-->
            <radialGradient id="radialGradient">
                <stop offset="10%" stop-color="red" />
                <stop offset="60%" stop-color="orange" />
                <stop offset="100%" stop-color="rgba(255,255,0,0.3)" />
            </radialGradient>
        </defs>

        <!--应用定义的渐变，通过url引用定义的渐变id-->
        <rect fill="url(#linearGradient)" x="10" y="40" width="200" height="100"/>
        <circle cx="100" cy="230" r="50" fill="url(#radialGradient)"></circle>
    </svg>
    关键点为：offset设置渐变位置，stop-color设置渐变色，通过url(#id)引用定义的渐变
</pre>
</div>
</li>

    <!--========================================== 定义、分组和引用-defs/symbol/g/use ==========================================-->
<li>
<h4 id="定义和分组">定义、分组和引用-defs/symbol/g/use <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--预定义要使用的图形或样式-->
        <defs>
            <!--定义一张嘴-->
            <polygon id="lens" points="65,50 185,50 185,75, 150,100 100,100 65,75" fill="red" stroke="purple" stroke-width="4" />
            <!--定义一个径向渐变-->
            <radialGradient id="irisGradient">
                <stop offset="25%" stop-color="green" />
                <stop offset="100%" stop-color="dodgerblue" />
            </radialGradient>
            <!--一个眼睛分组，看作一个整体-->
            <g id="eye">
                <ellipse cy="50" rx="50" ry="25" fill="none" stroke="black" />
                <circle cy="50" r="25" />
                <circle cy="50" r="10" fill="black" />
            </g>
        </defs>

        <!--两只眼睛作为一个整体放在一个分组中，并设置属性让其内部元素继承-->
        <g stroke="red" stroke-width="3" transform="translate(-50,0)">
            <!--单独绘制左眼，且也作为一个整体-->
            <g>
                <ellipse cx="125" cy="50" rx="50" ry="25" fill="none" stroke="black" />
                <circle cx="125" cy="50" r="25" fill="url(#irisGradient)" />
                <circle cx="125" cy="50" r="10" fill="black" />
            </g>
            <!--使用预定义的图形绘制右眼，并使之属性让其内的元素继承-->
            <use xlink:href="#eye" x="250" fill="dodgerblue" />
        </g>
        <!--使用定义的嘴-->
        <use xlink:href="#lens" transform="translate(10,50)"/>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--定义，使用 defs 元素定义待使用的部件，这些定义可以重复使用，其中定义的部件以唯一id为标识，定义中的图形不会绘制，只是保留代码-->
        <defs>
            定义部件代码...：1、定义一个径向渐变；2、定义一只眼睛图形并作为一个整体
        </defs>

        <!--除了defs用于定义，symbol标签也可以用于模板定义-->
        <symbol viewBox="0 0 150 100">
            defs标签是官方推荐用于预定义的标签，而symbol就是纯粹的模板标签，功能与defs完全一样，使用其定义的内容也是用use标签，只是symbol标签可以独立于svg标签上的而单独设置其 viewBox 和 preserveAspectRatio 属性
        </symbol>

        <!--分组，使用 g 元素进行图形分组或组合，其内部图形可继承g标签上的样式设置，且 g 标签可多次嵌套-->
        <g>
            组内部件代码...：1、单独绘制左眼并使用定义的渐变填充瞳孔周围；2、使用use引用定义的眼睛图形
        </g>

        <!--使用<use xlink:href="#id"/>可引用在defs/symbol中定义的图形，也可以引用定义外的图形或分组(包括在此之前声明的其他svg标签中的相关内容)，还可以在 use 元素上设置fill、stroke等属性，也会被使用的组件内部元素继承-->
        <use xlink:href="#id" />也可以引用预定义之外的图形或分组，use标签上的样式设置不会覆盖其引用的预定义外部的内容样式，但会覆盖引用的预定义内部的内容样式
        <!-- 注意：use 还可以引用外部独立 svg 文件中的相关内容，如：xlink:href="../iconfont/icon.svg#id" -->
    </svg>
    关键点为：&lt;defs>标签预定义、&lt;symbol>标签预定义、&lt;g>标签分组、&lt;use xlink:href="#id"/>标签引用
</pre>
</div>
</li>

    <!--======================================= 图片-image和线段始末标记-marker =======================================-->
<li>
<h4 id="图片">图片-image和线段始末标记-marker <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386#item-5-16">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <!--marker标签一般用来画箭头或线段始末的标记图形-->
            <marker id="triangle" viewBox="0 0 10 10" refX="3" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
        </defs>

        <!--marker-end属性表示结尾处的标记引用-->
        <polyline points="10,80 50,80 50,20 90,20" fill="none" stroke="black" stroke-width="2" marker-end="url(#triangle)" marker-mid="url(#triangle)" transform="translate(150,10)"/>

        <!--image标签引用jpg/png图片-->
        <image xlink:href="../知识点截图/svg/svg之viewport和viewbox对齐.png" x="10" y="10" width="100" height="80"/>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <!-- marker 标签一般用来画箭头或线段始末的标记图形，该元素放在 defs 中定义，以便其他地方引用 -->
            &lt;marker id="triangle"
                viewBox="单独定义标记的viewBox"
                preserveAspectRatio="单独定义标记的preserveAspectRatio"
                markerUnits="标记尺寸单位参照，默认strokeWidth(表示标记的单位尺寸为引用该标记的图形的线宽，故标记大小会根据引用图形线宽自动缩放)，可选userSpaceOnUse(表示标记的单位尺寸与整体画布上的单位相同，故不管线宽多大，标记大小都保持不变)"
                markerWidth="标记宽度"
                markerHeight="标记高度"
                refX="标记相对X轴方向的偏移量，可以是数字(可正负,偏移方向与坐标轴方向关系相反)、百分比、left/center/right关键字"
                refY="标记相对Y轴方向的偏移量，可以是数字(可正负,偏移方向与坐标轴方向关系相反)、百分比、top/center/bottom关键字"
                orient="标记相对引用元素的朝向，默认auto(标记所在点切向方向)，可选值：auto-start-reverse(同auto,只是marker-start位置会与auto反向)、数字、角度(同数字，只是多个单位deg)"
            &gt;
                <!-- 内部用其他元素定义标记形状 -->
                <path d="M 0 0 L 10 5 L 0 10 z" />
            &lt;/marker>
        </defs>

        <!-- 元素上使用 marker-start、marker-end 或 marker-mid，表示标记放在图形起点、终点 或 中间(所有拐点) -->
        <polyline points="110,80 50,80 50,20 90,20" fill="none" stroke="black" stroke-width="2" marker-end="url(#triangle)" />

        <!-- image标签引用jpg/png图片 -->
        <image xlink:href="图片地址" x="放置位置x坐标" y="放置位置y坐标" width="宽" height="高" preserveAspectRatio="可自定义放缩模式"/>

    </svg>
    关键点为：marker标签、image标签
</pre>
</div>
</li>

    <!--============================================= 填充(笔刷)-pattern =============================================-->
<li>
<h4 id="填充">填充(笔刷)-pattern <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386#item-5-15">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <!--pattern标签用来定义用于平铺填充的图形，类似于CSS中重复平铺背景图效果-->
            <pattern id="star" x="7" y="7" width="0.15" height="0.15">
                <!--内部绘制用于填充的图形或图片-->
                <polygon points="0,0 2,5 0,10 5,8 10,10 8,5 10,0 5,2"/>
            </pattern>
        </defs>

        <rect x="10" y="10" width="100" height="100" fill="url(#star)" stroke="red"/>
        <circle cx="180" cy="60" r="50" fill="none" stroke-width="20" stroke="url(#star)"/>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <!--pattern标签用来定义用于平铺填充的图形，效果类似于CSS中重复平铺背景图-->
            <pattern id="star" x="起始填充位置相对容器的x偏移量" y="起始填充位置相对容器的y偏移量" width="该填充物相对与容器的百分比宽度" height="该填充物相对与容器的百分比高度">
                <!--内部绘制用于填充的图形或图片-->
                <polygon points="0,0 2,5 0,10 5,8 10,10 8,5 10,0 5,2"/>
            </pattern>
        </defs>

        <!--引用定义的填充-->
        <rect x="10" y="10" width="100" height="100" fill="url(#star)" stroke="black"/>
        <circle cx="180" cy="60" r="50" fill="none" stroke-width="20" stroke="url(#star)"/>

    </svg>
    关键点为：pattern标签
</pre>
</div>
</li>

    <!--================================================ 滤镜-filter ================================================-->
<li>
<h4 id="滤镜">滤镜-filter
  <a target="_blank" class="mgl-30" href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter">参考文章1</a>
  <a target="_blank" class="mgl-30" href="https://juejin.cn/post/6844903734741319687">参考文章2</a>
  <a target="_blank" class="mgl-30" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">文档-滤镜</a>
  <a target="_blank" class="mgl-30" href="https://yoksel.github.io/svg-filters/#/">工具-滤镜图元效果在线演示</a>
  <a target="_blank" class="mgl-30" href="https://yoksel.github.io/svg-gradient-map/#/">工具-滤镜混合效果在线演示</a>
</h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box transition">
  <style>
    .svg-filter:hover .goo circle {
      cx: 50%;
    }
    .svg-filter:hover .goo rect {
      x: 50%;
    }
  </style>
    <svg class="svg-filter" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--预定义要使用的图形或样式-->
        <defs>
          <filter id="filter">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"/>
            <feOffset in="blur" dx="3" dy="4" result="offset" />
            <feColorMatrix in="offset" type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.6 0" result="color" />
            <feBlend in="SourceGraphic" in2="color" />
          </filter>
          <filter id="filter2">
            <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur"/>
            <feOffset in="blur" dx="10" dy="10" result="offset" />
            <feColorMatrix in="offset" type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.6 0" result="color" />
            <feComposite in="SourceGraphic" in2="color" operator="atop"/>
          </filter>
          <filter id="goo">
            <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
            <feColorMatrix in="blur" type="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
            <!-- 该滤镜图元会使上面输出的图形棱角变得平滑(即变成圆角) -->
            <feComposite in="SourceGraphic" in2="goo" operator="atop"/>
          </filter>
          <filter id="blur">
            <feGaussianBlur in="SourceGraphic" stdDeviation="3"/>
          </filter>
          <filter id="offset">
            <feOffset dx="3" dy="4" />
          </filter>
          <filter id="morphology">
             <feMorphology operator="erode" radius="3"></feMorphology>
           </filter>
        </defs>

        <g class="goo" filter="url(#goo)">
          <circle cx="20%" cy="55%" r="25" fill="red"/>
          <circle cx="50%" cy="55%" r="25" fill="red"/>
          <circle cx="80%" cy="55%" r="25" fill="red"/>
        </g>
        <g transform="translate(150, 200)">
          <rect x="0" y="0" width="60" height="40" fill="blue" filter="url(#filter2)"/>
          <text x="20" y="20">合成</text>
        </g>
        <g transform="translate(10, 10)">
          <rect x="0" y="0" width="50" height="50" fill="blue" filter="url(#filter)"></rect>
          <text x="10" y="20" fill="#fff">综合</text>
        </g>
        <g transform="translate(70, 10)">
          <rect x="0" y="0" width="50" height="50" fill="blue" filter="url(#blur)"></rect>
          <text x="10" y="20" fill="#fff">blur</text>
        </g>
        <g transform="translate(130, 10)">
          <rect x="0" y="0" width="50" height="50" fill="blue" filter="url(#offset)"></rect>
          <text x="5" y="30" fill="#fff">offset</text>
        </g>
        <g transform="translate(190, 10)">
          <rect x="0" y="0" width="90" height="50" fill="blue" filter="url(#offset)"></rect>
          <text x="5" y="30" fill="#fff">morphology</text>
        </g>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--定义，使用 defs 元素定义待使用的部件，这些定义可以重复使用，其中定义的部件以唯一id为标识-->
        <defs>
          <filter id="filter" x="0" y="0" width="1" height="1" filterUnits="filter元素坐标参照，默认objectBoundingBox(引用元素的盒子比例)" primitiveUnits="内部滤镜图元坐标参照，默认userSpaceOnUse(同外部图形坐标系)">
            <!-- 一个filter中可以有多种滤镜效果共同作用，每个滤镜效果称为一个滤镜图元或原子滤镜 -->
            <!-- 高斯模糊 -->
            &lt;feGaussianBlur
              in="设置滤镜图元输入来源(输入源，所有滤镜图元都有该属性)，可设为其他图元的result值或提供的关键字，若未设置且该图元是第一个则默认SourceGraphic(来自图形本身)，若未设置且该图元不是第一个则默认使用其前面图元的result值，`SourceAlpha`关键字也表示输入源为自身(但其只使用原图的透明度，设置阴影时使用该值可调整阴影深浅)，目前其他关键字浏览器暂未实现"
              stdDeviation="模糊操作的标准差，值越大越模糊，可设置数值分别表示横向和纵向标准差，一个值时表示横纵一样"
              result="给该滤镜图元的输出结果命名(所有滤镜图元都有该属性)，以便可作为后面滤镜图元的输入源，如自定义为shadow(可以重名，此时后面图元`in`属性使用该重名result时将以距离其最近的该result图元为准)"
            /&gt;

            <!-- 偏移 -->
            <feOffset dx="横向偏移距离" dy="纵向偏移距离" />

            <!-- 纯色填充，将直接覆盖填充应用该滤镜的区域 -->
            <feFlood flood-color="填充颜色" flood-opacity="透明度" />

            <!-- 颜色矩阵，用于颜色计算输出，关于颜色矩阵的计算方式可参考：https://juejin.cn/post/6844903734741319687#heading-2，https://www.w3cplus.com/svg/finessing-fecolormatrix.html -->
            &lt;feColorMatrix in="SourceGraphic"
              type="颜色计算类型，matrix(默认，rgba全颜色矩阵)、saturate(饱和度)、hueRotate(色调旋转角度)、luminanceToAlpha(亮度透明度)"
              values="根据前面type的值不同而不同
                      matrix时为20个数字的4x5矩阵，1 0 0 0 0, 0 1 0 0 0, 0 0 1 0 0, 0 0 0 19 -9
                      saturate时为介于0到1的一个数值
                      hueRotate时为一个数值(表示旋转度数)
                      luminanceToAlpha时values属性无效"
            /&gt;
            <!-- 混合，将两个图形组合在一起并使其受特定的混合模式控制(即图层重叠时重叠位置的颜色显示模式) -->
            <feBlend in="SourceGraphic"
              in2="in2表示第二个输入源(目标源，三个元素可使用该属性：feBlend、feComposite、feDisplacementMap)，将输入源与目标源进行作用"
              mode="混合模式，normal(默认，顶层颜色)、multiply(顶层与底层颜色相乘)、更多模式可查看blend-mode参考文章"
            />

            <!-- 合成，决定两个输入源的像素合成输出结果，该滤镜图元operator属性设为atop后将遮掉除了胶粘效果之外的东西（比如分明的棱角会变得平滑） -->
            &lt;feComposite in="SourceGraphic" in2="goo"
              operator="设置合成操作的方式，默认over，实测发现若有阴影偏移等效果会对结果造成影响
                        over：将`in`中的源覆盖在`in2`中源之上
                        in：显示`in`中与`in2`重叠的部分
                        out：显示`in`中与`in2`非重叠部分
                        atop：显示`in2`中与`in`重叠的部分
                        xor：`in`与`in2`非重叠部分都显示
                        lighter：`in`与`in2`都显示
                        arithmetic：将根据其他属性按公式 k1*i1*i2 + k2*i1 + k3*i2 + k4 计算像素点结果"
            /&gt;

            <!-- 变形，腐蚀(收缩薄化)或扩张(膨胀加厚) -->
            &lt;feMorphology
              operator="变形操作类型：erode(默认)、dilate
                        erode：使像素点变稀薄(收缩)，将每个像素分别设置为每个R、G、B、A通道中最暗或最透明的值(透明度针对in为SourceAlpha)
                        dilate：使像素点变厚重(扩张)，将每个像素的每个通道分别设置为其相邻像素的最亮或最不透明的值"
              radius="变形半径，两个值时则分别表示横纵方向半径"
            /&gt;

            <!-- 合并，即将多个滤镜图元(图层)合并到一起 -->
            <feMerge>
              <!-- `feMerge`下多个`feMergeNode`节点指定不同的输入源，注意顺序越在后面层级越高 -->
              <feMergeNode in="shadow" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>

          </filter>
        </defs>

        <!-- 通过 filter 属性引用定义的滤镜 -->
        <rect x="10" y="10" width="50" height="50" />

        <!-- 对于粘滞融合，要把滤镜放在元素的包裹容器上，而不是元素本身上，且对于不带圆角的形状融合非常不自然，所以一般用于带圆角的图形 -->
        <g filter="url(#blur)">
          <rect x="10" y="10" width="50" height="50" />
          <rect x="70" y="10" width="50" height="50" />
        </g>
    </svg>
    关键点为：filter标签和属性
</pre>
    </div>
</li>

    <!--=============================================== 裁剪-clipPath ===============================================-->
<li>
<h4 id="裁剪">裁剪-clipPath <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000009378881">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 210px;">
    <div class="left-box">
      <style>
        .svg-clipPath:hover circle {
          cx: 70%;
        }
      </style>
        <svg class="svg-clipPath" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <!-- 预定义要使用的图形或样式 -->
            <defs>
                <!-- 定义裁剪路径，可以是任何形状或文本 -->
                <clipPath id="clipPath">
                    <text x="0" y="60" style="font-size: 50px;font-weight: bold;">CLIP PATH</text>
                </clipPath>
            </defs>

            <!-- 使用裁剪，clip-path属性通过url指向定义的裁剪路径ID，显示的最终效果就是裁剪路径覆盖到被裁剪图形上的部分才会显示，未覆盖的部分就不会显示 -->
            <circle cx="20" cy="50" r="40" fill="red" clip-path="url(#clipPath)"/>
        </svg>

    </div>
<pre class="right-box">
<svg xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <!--clipPath中定义裁剪路径，可以是任何形状或文本-->
        <clipPath id="clipPath" clipPathUnits="clipPath的子元素使用的坐标系参照，可选值：userSpaceOnUse(默认值，使用引用该蒙版的元素的所在坐标系[绝对值]，即SVG与其他形状都统一)，objectBoundingBox(使用引用该裁剪路径的元素的盒子尺寸的百分比/浮点数[比例值])">
            <text x="0" y="50" style="font-size: 50px;font-weight: bold;">CLIP PATH</text>
        </clipPath>
    </defs>

    <!--使用裁剪，clip-path属性通过url指向定义的裁剪路径ID，显示的最终效果就是裁剪路径覆盖到被裁剪图形上的部分才会显示，未覆盖的部分就不会显示-->
    <circle cx="20%" cy="20%" r="40" fill="red" clip-path="url(#clipPath)"/>
</svg>
关键点为：clipPath标签定义裁剪路径、clip-path="url(#id)"属性使用定义的裁剪路径，只有被裁剪路径覆盖到的部分才会显示，未覆盖的部分就不会显示
</pre>
    </div>
</li>

    <!--================================================ 遮罩/蒙版-mask ================================================-->
<li>
<h4 id="遮罩">遮罩/蒙版-mask <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000012071386#item-5-14">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box">
    <style>
      .svg-mask rect:hover + defs circle {
        cx: 100;
        cy: 50;
      }
    </style>
    <svg class="svg-mask" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <!-- 通过 mask 属性引用指定的遮罩/蒙版 -->
        <rect x="10" y="10" width="100" height="50" fill="red" stroke="blue" stroke-width="5" mask="url(#mask1)"/>

        <!-- 这里放在后面是方便css选择器匹配hover状态 -->
        <!--预定义要使用的图形或样式-->
        <defs>
            <!--定义遮罩/蒙版-->
            <mask id="mask1" x="0" y="0" width="1" height="1">
                <circle cx="20" cy="20" r="30" stroke="blue" fill="white"/>
            </mask>
        </defs>

    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        <!--定义，使用 defs 元素定义待使用的部件，这些定义可以重复使用，其中定义的部件以唯一id为标识-->
        <defs>
            <!-- 使用mask标签定义遮罩/蒙版，蒙版的效果可以看做是更高级的裁剪路径 -->
            <!-- mask标签内部可以使用任意svg形状，且通过描边和填充的颜色值来定义应用该遮罩/蒙版的形状对应位置的透明度 -->
            <!-- 越接近白色#ffffff值则越不透明，而越接近黑色#000000值则越透明，即与类似opacity值的关系就是：#ffffff===1，#000000===0，也可以结合透明度属性使用，若使用图片填充则色值就是图片各部分的色值 -->
            <!-- 所以可以使用渐变色得到渐变透明度，使用图片得到不同位置的透明度，none值等同于黑色 -->
            <!-- x、y、width、height属性定位蒙版的位置和尺寸，其取值类型取决于maskUnits属性 -->
            &lt;mask
              id="mask1" x="0.1" y="0.1" width="1" height="1"
              maskUnits="mask元素的坐标单位参照(即x、y值的参照)，可选值：objectBoundingBox(默认值，使用引用该蒙版的元素的盒子尺寸的百分比/浮点数[比例值])，userSpaceOnUse(使用引用该蒙版的元素的所在坐标系[绝对值]，即SVG与其他形状都统一)"
              maskContentUnits="mask中子元素的使用的坐标和单位参照，userSpaceOnUse(默认值) | objectBoundingBox，含义同上"
            >
                <circle cx="20" cy="20" r="20" stroke="blue" fill="white" fill-opacity="0.7"/>
            &lt;/mask>
        </defs>

        通过mask属性引用上面遮罩/蒙版定义的id来使用遮罩/蒙版，应用遮罩/蒙版的图形中只有在遮罩/蒙版mask中定义的形状区域内可见，其他区域不可见
        <rect x="1" y="1" width="50" height="50" fill="red" mask="url(#mask1)"/>
    </svg>
    关键点为：&lt;defs>标签、&lt;g>标签、&lt;use xlink:href="#id"/>标签，蒙版的效果可以看做是更高级的裁剪路径
</pre>
    </div>
</li>

    <!--================================================== 变换-transform ==================================================-->
<li>
<h4 id="变换">变换-transform <a target="_blank" class="mgl-30" href="https://svg.brucewar.cn/33.SVG变换.html">参考文章</a></h4>
<div class="box-wrap clearfix" style="height: 270px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg">
        <!-- svg中标签上的`transform`属性中的变换值都没有单位，且多个变化类型之间、变换类型中的参数值之间都用空格隔开 -->
        <rect x="50" y="50" height="110" width="110" stroke="red" fill="#ccccff" transform="translate(30) rotate(45,50,50)" />
        <text x="0" y="0" transform="translate(20,130) scale(1.5)">Hello World!</text>
        <rect x="0" y="0" height="40" width="40" fill="rgba(255,0,0,0.6)" transform="translate(10,10) skewX(30)" />
        <rect x="10" y="10" height="40" width="40" fill="rgba(0,255,0,0.6)" transform="skewX(30)" />
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
        svg中图形标签上的`transform`属性的用法跟CSS中的基本一样，但svg中标签上的变换类型中的参数值都不带单位，而CSS中要带相应单位，
        svg中transform的效果也可以直接使用CSS中的transform来实现，配合使用的还有CSS中的`transition`，注意svg中标签上并没有`transition`属性.
        <!-- 注意，每种变换的都是相对于前一次变换后的坐标系进行的，且都是以原点为变换中心 -->
        <rect x="50" y="50" height="110" width="110" stroke="red" fill="#ccccff" transform="translate(30) scale(2) rotate(45,50,50)" />
        <!-- translate 可接受两个参数分别表示x、y轴上的偏移量，只传入一个参数时则只表示x轴上的偏移量，且没有`translateX`这样单独针对某个坐标轴的属性 -->
        <rect transform="translate(x,y)" />
        <!-- scale 可接受一个或两个参数，分别表示x、y轴上的缩放倍数，只传入一个参数时表示x、y轴上缩放相同的倍数，且没有`scaleX`这样单独针对某个坐标轴的属性 -->
        <rect transform="scale(x,y)" />
        <!-- rotate 可接受一个或三个参数，第一个参数表示旋转角度数，后两个参数表示旋转的参考点，省略则默认为(0,0)原点，且没有`rotateX`这样单独针对某个坐标轴的属性 -->
        <rect transform="rotate(deg)" />
        <!-- skewX、skewY 接受一个参数，表示沿对应轴方向扭曲的角度 -->
        <rect transform="skewX(deg)" />
        <rect transform="skewY(deg)" />
    </svg>
    关键点为：
</pre>
</div>
</li>

    <!--================================================== SVG动画 ==================================================-->
<li>
<h4 id="动画">SVG动画（IE不支持，包括IE11，部分可使用CSS3中的动画或过渡替代）
    <a target="_blank" class="mgl-30" href="https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/">参考文章1</a>
    <a target="_blank" class="mgl-30" href="https://segmentfault.com/a/1190000009378881">参考文章2</a>
</h4>
<div class="box-wrap clearfix">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg">
      <circle cx="50" cy="50" r="30" fill="red">
        <animateTransform attributeName="transform" type="scale" from="1" to="1.5" dur="2s" fill="freeze" begin="click" id="scale" />
        <animate attributeName="cx" attributeType="XML" from="50" to="200" dur="2s" fill="freeze" begin="scale.begin" />
      </circle>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
      <!-- 将下面的动画声明元素包裹在要动画化的对象图形中，可以包裹多条动画声明以形成组合动画，如下形式： -->
      <g>
        <animate attributeName="x" attributeType="XML" from="20" to="200" begin="0s" dur="5s" fill="freeze" />
        <animateMotion path="..." begin="0s" dur="3s" />
      </g>

      <!-- animate 元素大多情况下可以当做css中`transition`使用，其上的属性在其他几个动画元素上也基本都适用 -->
      &lt;animate
        attributeName="要动画的属性(也可以是CSS属性)，如：width"
        attributeType="上面要动画化的属性的类型，有三个值可选：CSS(css属性)、XML(xml属性，即标签上的描述属性)、auto(默认，自动判断，实际先按CSS查找，若不是再按XML查找)"
        from="起始值"
        to="终点值"
        by="相对变化值"
        values="用分号分隔的多个值，表示是动画的多个节点值(from、to、by、values这几个属性性质属于同一类，故相互间有制约，可出现的组合有from-to、from-by、to、by、values)"
        begin="动画开始时间，可为单值或分号分隔的一组值，表示多个起始时间点，默认应该是0，表示文档加载完就立即开始"
        dur="动画持续时长，单位可以是h、min、s(默认)、ms"
        end="动画结束时间，该属性不设置时会默认自动计算(即不设置也存在，也可读)"
        repeatCount="动画重复次数，可以是整数值或`indefinite`(无数次)"
        repeatDur="动画重复总时间，可以是有限时间长度(如10s)或`indefinite`(无限长)，与repeatCount会同时限制，任一条件先达到限制就会停止动画"
        min="动画执行最短时间，若动画整个执行时长没有min大，则动画完成停止后时间达到min设定的时间时其将立刻跳到按照循环播放时该时刻动画所在的位置"
        max="动画执行最长时间，即使动画设置了重复，达到该max设定的时间时动画仍将停止，循环动画中可以跟`repeatDur`起到一样的效果"
        accumulate="动画重复或循环时，是否在前一次动画上累积后执行后面的动画(即后一次动画从前一次动画结束位置状态开始)，默认`none`每次重头开始、`sum`则表示在前一次的基础上累积"
        additive="控制动画是否附加，后面的动画开始执行时是否附加在前面动画的效果上执行(即前面未结束的是否立即终止)，主要针对同一类动画(变化同一属性)，对于非同类动画影响不大，
                  默认值`replace`直接替换前面的动画(即后面的开始执行时，前面的就立即变为结束状态)、`sum`则表示附加在前面动画的基础上执行(即不直接终止前面的动画，重合的时间段内会同时播放)，
                  如`animateTransform`动画都使用`transform`属性，但`type`还分旋转缩放平移扭曲等，此时默认情况下后面的开始执行就会覆盖前面的(前面的动画直接结束)，几种变换就没法同时进行"
        fill="动画结束时状态，freeze(冻结，即停留在结束位置)、remove(默认值，表示回到开始位置)"
        restart="重新开始动画的方式(主要针对事件触发动画的方式，例如通过点击触发动画，若连续点击时这将决定后面的点击什么情况下动画重新播放才有效)，
                 默认`always`(始终有效，每次点击都将立即结束当前未完成动画而从头开始)、`whenNotActive`(当前动画是未激活状态才有效，即当前动画还未完成时则无效)、`never`(只有初次点击有效，后面的都忽略)"
        calcMode="插值计算模式，即动画属性起点状态到终点状态的变化曲线，有四个可选值：discrete(直接从from大屏to)、linear(线性匀速变化，默认值[除animateMotion元素(其默认paced)])、
                  paced(插值定义均匀变化，仅支持数值类属性，优先级高于keyTimes和keySplines)、
                  spline(插值定义贝塞尔曲线，spline点的定义在keyTimes属性中，每个时间间隔控制点由keySplines定义)"
        keyTimes="关键时间节点，值也为一组分号分隔的值，节点数与`values`属性节点数对应，若是`from/to/by`动画，则其必须至少有两个值(起点/终点)，
                  对于`calcMode`为`linear`或`spline`时，其值第一个和最后一个分别要为`0`和`1`，且中间的节点每个要比前一个大，即表示每个节点所在动画过程中的时间比例(类似CSS中的keyframes动画)，
                  `calcMode`为`paced`模式，或`dur`为`indefinite`时，或keyTimes定义错误，keyTimes都会被忽略"
        keySplines="该属性是与`keyTimes`相关联的一组分号分隔的贝塞尔控制点(每个控制点由4个浮点数值表示`x1 y1 x2 y2`，每个取值范围为0~1，默认`0 0 1 1`)，但值个数始终要比`keyTimes`少一个，
                    该属性只在`calcMode`为`spline`模式时有效，且若该属性的值不合法或个数不对也都是没有动画效果的"
      />
      <!--
        from、to、by、values 属性说明：
        1、若起始值与元素默认值相同，则可省略`from`属性；
        2、to、by 两个参数至少有一个要出现(不考虑values情况下)，`to`为变化到多少(绝对值)、`by`为增加多少(相对值)；
        3、to、by 若两者都出现，则只有`to`有效；
        4、当设置了`values`属性且其值有效时，from, to, by的值都会被忽略；`values`设置多个值时第一个值就代表from，后面的值可以看做依次阶段的to，如：values="160;40;100"
        总结这几个属性可组合或单独出现的情况：from-to、from-by、to、by、values

        begin、end 时间设定属性说明：
        begin 属性值为一组值时表示多个起始时间点，如：beigin="3s;5s"，表示3s后动画播放一下，5s后动画又播放一下(若此时前一次动画还未结束则会立即停止从头开始)，故若一次动画时长为3s，即dur="3s"，且无repeatCount属性时，可看到动画连续执行了2次
        begin 除了普通单值，还有以下方式使用的单值(end同样适用)：
        1、+/-t，表示一个相对偏移值，如：begin="+3s"，相对document的begin值延迟3s；
        2、[动画元素的id].begin/end +/- t，表示相对某id动画元素的begin/end值偏移t时间，可实现两个独立元素的动画级联效果，如：begin="el.end+1s"，表示当前动画在id为el的动画结束后1s开始；
        3、[图形元素的id].[事件类型] +/- t，表示相对某id图形元素的某事件触发后偏移t时间，如：begin="circle.click"，表示点击id为circle的图形元素时当前动画开始播放(若是元素自身的事件则可以只写事件)；
           包含的合法事件(并非所有元素都支持全部事件)可参考：https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/begin
        4、[动画元素的id].repeat(n) +/- t，表示某id动画重复播放n(整数)次后再偏移t时间，如：begin="el.repeat(2)"，表示id为el的动画播放两次后当前动画开始播放；
        5、accessKey("character")，character为快捷键所在的字符，表示按下对应的键时动画开始播放(实测无效)，如：begin="accessKey(s)"，表示按下`s`键时动画开始播放；

        上面提到的动画关键节点设置实际就是`values`(from/to/by)、`keyTimes`、`keySplines`之间的关系：
        `values`确定节点位置的动画属性的值，`keyTimes`确定到每个节点需要的时间，`keySplines`则确定的是每个时间段之间的贝塞尔曲线(即每段动画具体的缓动表现)。
        这与我们平时CSS3写的`transition`过渡效果类似，只是`transition`中相当于values值就两个(起始状态值/终止状态值，同from/to/by)，故`keyTimes`只能是`0;1`，而`keySplines`贝塞尔曲线也就只有一个(ease/linear等)。

      -->

      <!-- animateColor 字面就可知其是颜色动画，该元素已废弃，因其效果完全可用`animate`元素变化颜色相关属性来实现 -->

      <!-- animateTransform 元素字面就可知其是通过`transform`属性进行动画化的(同CSS中) -->
      <animateTransform attributeName="transform" type="scale" begin="0s" dur="3s" from="1" to="1.5" repeatCount="indefinite" />

      <!-- animateMotion 元素用于运动动画(或称路径动画) -->
      <animateMotion path="M10,80 q100,120 120,20 q140,-50 160,0" begin="0s" dur="3s" rotate="auto" repeatCount="indefinite" />
      <animateMotion begin="0s" dur="3s" rotate="auto" repeatCount="indefinite">
        <mpath xlink:href="#path"/>
      </animateMotion>

      <!-- set 元素并没有动画效果，其只是可以设置延时改变某个属性值，这个过程是瞬间的，而不是逐渐过渡（所以其attributeName也可设置为任意非可插值类的属性名） -->
      <!-- 下面这个设定表示3s后(begin)要动画化的元素的x属性(attributeName)值变为(to)60 -->
      <set attributeName="x" attributeType="XML" to="60" begin="3s" />
    </svg>
    关键点为：
</pre>
</div>
</li>

<li>
<h4 id="变形动画">变形动画</h4>
<div class="box-wrap clearfix" style="height: 120px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg">
        <path fill="#1EB287">
            <animate
                    attributeName="d"
                    dur="1440ms"
                    repeatCount="indefinite"
                    calcMode="spline"
                    keyTimes="0;
                       .0625;
                       .208333333;
                       .3125;
                       .395833333;
                       .645833333;
                       .833333333;
                       1"
                    keySplines="0,0,1,1;
                         .42,0,.58,1;
                         .42,0,1,1;
                         0,0,.58,1;
                         .42,0,.58,1;
                         .42,0,.58,1;
                         .42,0,.58,1"
                    values="M 0,0
                     C 50,0 50,0 100,0
                     100,50 100,50 100,100
                     50,100 50,100 0,100
                     0,50 0,50 0,0
                     Z;

                     M 0,0
                     C 50,0 50,0 100,0
                     100,50 100,50 100,100
                     50,100 50,100 0,100
                     0,50 0,50 0,0
                     Z;

                     M 50,0
                     C 75,25 75,25 100,50
                     75,75 75,75 50,100
                     25,75 25,75 0,50
                     25,25 25,25 50,0
                     Z;

                     M 25,50
                     C 37.5,25 37.5,25 50,0
                     75,50 75,50 100,100
                     50,100 50,100 0,100
                     12.5,75 12.5,75 25,50
                     Z;

                     M 25,50
                     C 37.5,25 37.5,25 50,0
                     75,50 75,50 100,100
                     50,100 50,100 0,100
                     12.5,75 12.5,75 25,50
                     Z;

                     M 50,0
                     C 77.6,0 100,22.4 100,50
                     100,77.6 77.6,100 50,100
                     22.4,100, 0,77.6, 0,50
                     0,22.4, 22.4,0, 50,0
                     Z;

                     M 50,0
                     C 77.6,0 100,22.4 100,50
                     100,77.6 77.6,100 50,100
                     22.4,100, 0,77.6, 0,50
                     0,22.4, 22.4,0, 50,0
                     Z;

                     M 100,0
                     C 100,50 100,50 100,100
                     50,100 50,100 0,100
                     0,50 0,50 0,0
                     50,0 50,0 100,0
                     Z;"/>
        </path>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
      <!-- 关键属性为如下几个 -->
      <animate calcMode="spline" keyTimes="..." keySplines="..." values="..." />
    </svg>
</pre>
</div>
</li>

<li>
<h4 id="路径动画">运动(路径)动画：animateMotion</h4>
<div class="box-wrap clearfix" style="height: 120px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="50 80 200 100">
        <path d="M50,125 C 100,25 150,225, 200, 125" stroke="red" fill="none" id="path"></path>
        <circle cx="0" cy="0" r="5" style="fill: #0f0;">
            <animateMotion path="M50,125 C 100,25 150,225, 200, 125" dur="3s" fill="freeze"/>
        </circle>
        <rect x="0" y="0" width="10" height="10" style="fill: #0f0;">
            <animateMotion dur="5s" rotate="auto" repeatCount="indefinite">
                <mpath xlink:href="#path"/>
            </animateMotion>
        </rect>
    </svg>
</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
      <!-- 直接通过`path`属性指定运动路径 -->
      <animateMotion path="M10,80 q100,120 120,20 q140,-50 160,0" begin="0s" dur="3s" rotate="auto" repeatCount="indefinite" />

      <!-- 使用`mpath`标签引用一个已存在或预定义的路径 -->
      <animateMotion begin="0s" dur="3s" rotate="auto" repeatCount="indefinite">
        <mpath xlink:href="#path"/>
      </animateMotion>

      <!-- 也可以使用基础的 values 或 from/to 等属性指定离散坐标位置，相关优先级如下： -->
      mpath > path > values > from/to
    </svg>
</pre>
</div>
</li>

<li>
<h4 id="线条动画">线条动画</h4>
<div class="box-wrap clearfix" style="height: 120px;">
<div class="left-box">
    <svg xmlns="http://www.w3.org/2000/svg">
        <text x="50%" y="80%" text-anchor="middle" font-size="100" fill="none" stroke="red" stroke-width="4" stroke-dasharray="10">SVG
          <animate attributeName="stroke-dashoffset" attributeType="XML" form="0" to="240" begin="click" dur="3s" fill="freeze" / >
        </text>
    </svg>

</div>
<pre class="right-box">
    <svg xmlns:xlink="http://www.w3.org/1999/xlink">
      <text x="50%" y="80%" text-anchor="middle" font-size="100" fill="none" stroke="red" stroke-width="4" stroke-dasharray="10">SVG
        <!-- 利用元素的`stroke-dasharray`和`stroke-dashoffset`属性值的变化来制作线条动画 -->
        <animate attributeName="stroke-dashoffset" attributeType="XML" form="0" to="240" begin="click" dur="3s" fill="freeze" / >
      </text>
    </svg>
</pre>
</div>
</li>

</ul>
<pre class="mgt-10">

    SVG的世界、视野、视窗的概念：
    svg标签中的代码定义世界
    svg标签上width、height属性控制视窗
    svg标签上viewBox、preserveAspectRatio属性控制视野，viewBox中的偏移设置时多设置0.5可使线条更加锐利纤细(浏览器一像素原理)

    <g>g标签可用于对svg内容进行分组，且其可以嵌套，绘制属性可被内部图形继承</g>

</pre>

<script src="../js/jquery-1.11.3.min.js"></script>
<script src="../plugins/google-code-prettify/prettify.js"></script>
<pre class="mgt-10">
<script>

    var SVG_NS = 'http://www.w3.org/2000/svg';      //SVG命名空间
    var XLINK_NS = 'http://www.w3.org/1999/xlink';  //xlink命名空间

    /** 基本操作API */
    //创建图形
    document.createElementNS(SVG_NS,tagName);   //因SVG定义有自己的namespace命名空间，其可以独立存为一个文件，所以创建SVG元素要使用createElementNS方法(SVG元素指所有构建svg图形的元素)
    //添加图形，同一般元素操作
    element.appendChild(childElement);
    //设置/获取普通属性，同一般元素操作
    element.setAttribute(name, value);
    element.getAttribute(name);
    //设置`xlink:href`等带有命名空间的属性时需要使用带命名空间的属性设置方法
    element.setAttributeNS(XLINK_NS, 'xlink:href', value);
    element.getAttributeNS(XLINK_NS, 'xlink:href');

</script>
</pre>
<script>
    $(function () {
        var pre = $('pre');
        pre.addClass('prettyprint linenums');
        pre.each(function () {
            var newHtml = this.innerHTML.replace(/</g,'&lt;').replace(/&lt;img/g,'<img');
            this.innerHTML = newHtml;

        });

        prettyPrint();

        var isDown = false;
        $('svg').on('mousedown', function(e) {
          isDown = true;
        });
        $('svg').on('mouseup', function(e) {
          isDown = false;
        });
        $('svg').on('mousemove', function(e) {
          // 若形状无填充则点击其内部不会触发其鼠标事件
          if (!isDown) return;
          var el = e.target, event = e.originalEvent;
          if (el.tagName.toLowerCase() !== 'svg') {
            // $(el).attr('transform', `translate(${event.movementX},${event.movementY})`);
          }
        });
    });
</script>





</body>
</html>