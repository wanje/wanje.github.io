<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>二阶段课堂笔记</title>
    <style type="text/css">

    </style>
</head>
<body>
    <h1>option+command+U 查看源文件</h1>
    <!--*********************************************************************************************************-->
    <!--********************************************* 第二部分start *********************************************-->
    <!--*********************************************************************************************************-->
    <div>
        头部head中<meta charset="utf-8">定义编码标准

        所有符号均在英文状态下输入

        html中注释内容用<!--内容-->（快捷键Ctrl+/）

        <b>文字加粗</b>，<strong>文字也会加粗显示，但表示加重语气</strong>，<em>强调文本，文本会倾斜显示</em>

        引用图片<img src="路径" alt="提示文字" title="鼠标提示文字">，img标签不会自动换行
        路径中，若图片与html文件在同一级文件夹内则可直接写引用的文件名，
        若在下级文件夹内则从与html文件同级的文件夹开始逐级写出目录，
        若图片在html文件的上级目录的子文件夹内，则须先往上寻找目录，每一个../符号表示向上寻找一级
        不可引用非本工程文件中的绝对路径，可引用网络上的绝对路径（http://加具体地址）
        alt属性是图片在浏览器中还未加载出来时显示的提示文字，
        title属性是当鼠标移入图片时显示的提示文字

        超链接<a href="连接路径">链接对象</a>,其中链接路径与img标签中的路径选择规则一样

        <ul>无序列表
            <li>内容1</li>
            <li>内容2</li>
        </ul>
        <ol>有序列表
            <li>内容1</li>
            <li>内容2</li>
        </ol>
        <dl>自定义列表
            <dt>列表标题</dt>
            <dd>列表项1</dd>
            <dd>列表项2</dd>
        </dl>

        <i>斜体</i>
        <s>中划线，定义不正确、不准确或没有用的文本</s>
        <del>删除线，定义替换和删除的文本</del>

        <span>跨字符标签，无默认样式，直接呈现文字，可设置属性改变样式，往往用于某个标签内部单独改变某一块</span>

        表格<table border="1" width="500" height="500" cellpadding="10" cellspacing="10"
        align="水平位置对其方式left" bgcolor="颜色单词/#十六进制/rgb(255,255,255)">
        <tr> <!--表格第一行，不单独设置宽度，但可以设置高度-->
            <th>表头1</th>
            <th>表头2</th>
            <th>表头3</th>
        </tr><br>
        <tr> <!--表格第二行-->
            <td valign="垂直位置对其方式top">单元格11</td>
            <td align="水平位置对其方式left">单元格12</td>
            <td>单元格13</td>
        </tr>
        <tr> <!--表格第三行-->
            <td colspan="跨列横向合并格数">单元格21</td>
            <td rowspan="跨行纵向合并格数">单元格22</td>
            <td>单元格23</td>
        </tr>
        可加上<thead></thead>,<tbody></tbody>,<tfoot></tfoot>来区分表格的头部、内容，尾部(不能跨这三部分)，合并单元格
        table中的宽、高、位置、背景属性也可用于每个单元格或整行
        同一行或列的不同单元格分别设置不同宽或高时，浏览器取其最大值显示
        align表示水平位置，valign表示垂直位置，bgcolor表示背景色,background表示引用背景图像
        其中的数字后面不用带单位，默认与像素px一样，cellpadding表示单元格内容与单元格边框的距离，cellspacing表示单元格边框与整个表格边框的距离或单元格之间的距离
        cellpadding和cellspacing在设置时前后左右是同时变化的，且它们是在table中使用，tr、td中不使用此属性
        colspan="跨列横向合并格数"， rowspan="跨行纵向合并格数"，合并后要删除被合并的单元格，否则会自动向后或下依次挤开而多余

        框架<iframe src="默认引用内容" name="给此iframe框架取名" frameborder="1/0表示显示边框与否" scrolling="no">
        iframe是内嵌元素，不会自动换行
        scrolling="no"表示不显示滚动条
        <a href="URL" target="显示连接的目标位置"></a>
        target="_blank"表示在新窗口打开连接，target="name名字"表示在上面的iframe中打开

        在PC端，tabindex="0"属性可以使非焦点元素获得焦点，并能通过tab键切换焦点，但其不能像焦点元素一样通过回车键可触发click点击事件，其只能通过再绑定键盘事件来实现回车键触发click事件，
        像这种非焦点元素充当按钮时可以加上：role="button" 属性指明其角色，这样更符合语义，也照顾到了屏幕阅读器这样的特殊环境

        关于父级窗口与子级iframe窗口间互相访问DOM结构的方法参阅：http://www.css88.com/archives/2343
        父窗口获得子级iframe窗口window对象：iframe节点.contentWindow 或 window.frames[index]（index是索引值）或 window.frames["iframeName"]；
                                            注意：window.frames["iframeName"]获取到的是iframe的window对象，而window.frames["iframeID"](document.frames["iframeID"]？IE6/7) 获取到的是iframe节点
        父窗口获得子级iframe窗口document对象：1、可通过上面方法获得window对象再.document；2、iframe节点.contentDocument（IE8+支持contentDocument）
        子级iframe窗口获得父窗口window对象：parent.document.getElementById("domID")，parent是父窗口（如果窗口是顶级窗口，那么parent==self==top），
        top是最顶级父窗口（有的窗口中套了好几层iframe），self是当前窗口（等价window），opener是用open方法打开当前窗口的那个窗口；

        锚点设置<a name="锚点名anchor">需设置锚点的对象</a> 或 <div id="ID">需设置锚点的对象</div>
        <a href="#锚点名anchor">链接到锚点anchor</a> 或 <a href="#ID">链接到id为ID的div</a>

        特殊符号：&nbsp;&nbsp;表空格(一个汉字的宽度)；&ensp;&ensp;表一个字母宽度的空格；&gt;表示大于号；&lt;表示小于号

        块级元素内可放所有元素（但p标签中不允许放h标签）并会自动换行，内嵌元素只能放内嵌元素且不自动换行
        <hr/>是分隔线标签，且是块级元素

        <form action="处理这个表单的地址URL" method="get/post提交方式">内容和表单控件</form>
        <fieldset>用于分组展示信息</fieldset>
        <legend>标题，画一个框包住表示框内都是此类信息</legend>/*可用于设置文字覆盖在横线上的样式*/
        <label>姓名：</label><input type="text" value="默认显示内容，可不设" size="文本框可显示的字符长度" maxlength="最大输入字符数" readonly="readonly(表示只读，不可修改)" disabled="disabled(表禁用，不可更改，也不会提交到服务器)"/>,用lable给表单控件作标注
        单选<input type="radio" name="同一类统一名字，如sex" checked="checked(表示默认选中)" value="选中则被提交的代表值"/>
        复选<input type="checkbox" name="同一类统一名字，如爱好，也可不设此属性" value="选中则被提交的代表值"/><br>
        下拉列表<select multiple="multiple(表可多选)" size="数字(表展开下拉列表时显示选项个数，可不设置)">
                    <option value="提交到后续设备的值1" selected="selected(默认选中项)">选项1</option>
                    <option value="提交到后续设备的值2">选项2</option>
                    <option value="提交到后续设备的值3">选项3</option>
                 </select>
        多行文本输入框<textarea rows="行数" cols="列数">预设内容</textarea>/*resize:none属性可设置禁止改变输入框的大小，设置overflow:auto可取消IE下默认显示滚动条*/
        密码<input type="password" placeholder="密码框提示文字"/>
        提交按钮<input type="button" value="提交">value设置提示文字，但此按钮不可真正提交数据，只起一个显示作用
        提交按钮<input type="submit" value="提交">默认显示"提交"，可通过value更改文字，点击可真实提交
        重置按钮<input type="reset" value="重置">
        form,fieldset是块级元素


        引入CSS方法：（CSS注释用/* */，快捷键Ctrl+/）
        1、<link rel="stylesheet" href="引用的CSS文件名">（放在head中）<!--导入外部样式表，因要求行为样式结构分离一般都采用此法-->
        2/3、<style type="text/css">
                选择器{ 样式设置 }/*内嵌样式，html文件中只能有一个，一般不用*/ 或 @import url("css文件名")/*导入样式，小网站一般不用这个，但可用于CSS文件中导入另外的CSS文件*/
             </style>（放在head中）
        4、<p style="color:pink;"><!--行间样式或内联样式，一般不用-->
        引入方式优先级：同一对象被多个样式包含时，采用就近原则显示，实际就是行间样式优先级最高

        语法结构：
        选择器{ 属性:属性值1;属性值2;属性值3;/*样式设置*/ }/*符号标点都是在英文状态下输入，且属性后是冒号:，而html标签中是等号=*/

        选择器：
        1、元素选择器：就是html中的标签
        2、id选择器：#id名{ 样式设置 }
        <p id="id名/*不可引用多个id*/">内容</p>/*命名不能以数字和特殊符号(除下划线_),驼峰命名法，见名知意*/
        3、class类选择器：.类名{ 样式设置 }
        <p class="类名1 类名2/*空格隔开，可引用多个类*/">内容</p>/*命名不能以数字和特殊符号(除下划线_),驼峰命名法，见名知意*/
        优先级：id>class>元素选择器 /*在{ }中加!important时，则此选择器优先级无条件变最高*/
        同一个id选择器只能被使用一次，而类选择器可多次使用

        复合选择器：
        后代选择器：父元素 子元素{ 属性设置 }/*不一定是一级子元素，而是里面所有此子元素，注意父子元素间有一个空格隔开*/
        交集选择器：元素.类名/#id名{ 属性设置 }/*作用于包含此类名或id名的这个元素*/
        并集选择器：几个选择器名并列，用逗号隔开{ 属性设置 }/*作用于选中的几个选择器*/

        字体属性：
        字体类型：font-family:"微软雅黑","字体2";<
        字体大小：font-size:30px/2em/100%;/*chrome正文字体大小默认16px；em是相对单位，表示相对其父元素字体大小的倍数；%比也是相对父元素字体大小的百分比大小*/
        字体颜色：color:red/#16进制/rgb(0,0,255)/rgb(10%,50%,100%)
        font-style:normal;/*显示默认正常样式*/
        font-style:italic;/*斜体，此斜体只能作用于字体本身可倾斜的字体上*/
        font-style:oblique;/*强制倾斜，包括艺术字*/
        font-weight:900;/*字体加粗，值100-900*/
        font-weight:bolder;/*bold粗体，bolder加粗*/
        font-weight:normal;/*默认不加粗，也可设置为100*/
        text-decoration：none；/*取消下划线正常显示，underline是加下划线，line-through是中划线，overline是上划线(顶线)*/
        text-transform：uppercase;/*小写转换成大写*/
        text-transform：capitalize;/*首字母大写*/
        text-transform：lowercase;/*大写转换成小写*/
        text-indent:32px/2em;/*段落首行缩进大小*/
        word-spacing:20px/2em;/*单词间距离设置，汉字间则需要用个空格隔开才起作用，否则浏览器会认为挨在一起的字都算一个词*/
        letter-spacing:20px/2em;/*单个字符间的距离*/
        text-align:center;/*文字水平对齐方式，也可用于图片(因都是div中的内容)*/
        vertical-align:top/middle/bottom/text-top/text-bottom;/*作用于img标签，表图片与文字在垂直方向上的对其方式(不是对于div)，也可用于表单控件与文字的对齐*/
        line-height:40px/2em/90%;/*文字行高，一行文字时，行高与文本框高度一致时文字才垂直居中*/

        div块：
        背景色：background-color:white/#/rgb;
        背景图片：backgpround-image:url("地址");；backgpround-repeat：no-repeat/repeat-x/repeat-y/repeat;/*背景图重复模式：不重复、横向重复、纵向重复*/
        背景图定位显示：background-position:left top/10% 50%/10px 100px;/*第一个是x轴方向，第二个是y轴方向，后面像素px设置方式数值可为负的*/
        使背景图位置固定，不随滚动条滚动：background-attachment:fixed;
        边框：border:1px solid #123456;/*边框线粗、线型、颜色；也可单独设置四条边的样式border-top/right/bottom/left-width/style/color:;*/
        outline:1px solid #123456;/*外边线，与border差不多，但是它不额外占据位置*/

        块级元素会自动换行，可设置其宽高和边框宽高并显示此大小，但它实际还是占据整行
        内嵌元素不可设置宽高，边框大小也由内容多少决定
        display:inline;/*显示方式变为行内*/
        display:block;/*显示方式变为块级*/
        display:inline-block;/*显示方式变为行内块级，并排显示，但宽高可设置，不一定为内容宽高*/
        display:none；/*隐藏，不显示，完全脱离文档流，释放空间，若要再显示则再设置显示方式即可，变化无过渡*/
        visibility:hidden;/*隐藏，不显示，但是它不会脱离文档流，也不会释放空间，只是透明化了本身，可过渡*/
        visibility:visible;/*显示前面设置的隐藏部分*/
        浮动float会把行内元素变为行内块级显示状态
        绝对定位position:absolute;和固定定位position:fixed;也会把行内元素变为行内块级显示状态

        div+css布局：
        浮动：float：left/right;清除浮动：clear:left/right/both;
        /*
        1、浮动会脱离正常的文档流
        2、在允许的空间内正常显示，若空间不够，则会挤下去，即换行
        3、浮动后把自己占据的宽度缩成内容的实际宽度，这部分内容还是会占据相应位置
        4、浮动会造成父元素塌陷，给父元素设置溢出隐藏overflow:hidden;可解决此问题
        溢出隐藏还可以解决与父块紧邻的子块将父块拉下来的问题（还有添加边框或文字空格来解决）
        overflow:visible;/*溢出可见*/
        浮动时上下边距合并原理失效
        */

        list-style:none;/*取消列表前面的点或序号*/
        a:link{ 属性设置 }/*未访问时a的属性设置*/
        a:visited{ 属性设置 } /*表示鼠标点击之后a的属性设置*/
        a:hover{ 属性设置 } /*表示鼠标移入a时的属性设置*/
        a:active{ 属性设置 }/*鼠标按下还未松开时选中状态a的属性设置，即点击时*/
        /*顺序是link，visited，hover，active*/
        属性cursor:pointer/*鼠标指针变成手型*/

        做下拉菜单时要每一级的高度设为auto以将下面的菜单推开

        定位：/*内嵌元素使用定位后也可设置宽高*/
        绝对定位：position:absolute;/*会完全脱离文档流，释放自己的空间，并以最近一个有定位（绝对或相对定位都可）的父元素作为参考点，若父元素都未设置定位，则以body的（0,0）作为参考点*/
                  left:200px;
                  top:100px;
                  z-index:1;/*层级关系设置，值-1到999，若未设置则默认按代码加载的顺序显示，后加载则在上面*/
        相对定位：position:relative;/*不会脱离文档流，不会释放自己的空间，相对于自己原来的正常位置进行偏移*/
                  left:200px;
                  top:100px;

        固定定位：position:fixed;/*脱离文档流，固定在浏览器视图窗口的设定位置，不会随滚动条滚动，也不会受父元素定位的影响*/
                  left:200px;
                  top:100px;

        粘性定位：position: -webkit-sticky;  /* IE不支持 */
                 position:sticky; /* 其表现介于relative和fixed之间，超过指定位置则fixed，否则relative */
                  top:100px;

        圆角设置：border-radius:1px 2px 3px 1px [/ 1px 2px 3px 1px];/*四个值顺序为左上、右上、右下、左下，若加上/后的一组值则前面一组表示水平半径、/后面一组表示垂直半径，一一对应，不加/后面的值则表示垂直于水平半径相同，
                                                                     *当框为正方形时直接写百分比%也可，>=50%则表示一个圆*/



        CSS3.0
        新增选择器：

        字符串匹配属性选择器：
        元素名[属性="值"]{ 属性设置 }<!--完全匹配-->
        元素名[属性^="值的开头几个字母**就行"]{ 属性设置 }/*匹配值开头为**的元素*/
        元素名[属性$="值的结尾几个字母**就行"]{ 属性设置 }/*匹配值结尾为**的元素*/
        元素名[属性*="值的任意几个字母**就行"]{ 属性设置 }/*匹配值中包含**的元素*/
        *{ 属性设置 }/*通配符选择器，选中所有元素*/

        结构性伪类选择器：
        父元素 子元素:nth-child(此子元素在此父元素包含的所有子元素中的顺序数/2n/2n+1){ 属性设置 }/*2n表示所有偶数序列，2n+1表示所有奇数序列*/
        父元素 子元素:first-child{ 属性设置 }/*(last-child最后一个)作用于此父元素的第一个子元素，要考虑其他子元素的位置，若此子元素不是在第一个则不起作用*/
        父元素 子元素:nth-last-child(此子元素在此父元素包含的所有子元素中的倒序数/2n/2n+1){ 属性设置 }
        父元素 子元素:only-child{ 属性设置 }/*作用于只有一个子元素且为此子元素的此父元素处*/
        父元素 子元素:only-of-type{ 属性设置 }/*作用于只有一个此子元素的此父元素处*/
        元素:nth-of-type(正序第*个此元素){ 属性设置 }/*作用于包含此元素的所有块内的第*个此元素，不考虑其他子元素(只是非同名标签的元素，同样标签名的不可忽略)的序列*/
                        须注意：之前使用中有所误解，其并不是单纯以冒号前选择器+索引位置进行匹配，其正确定义和匹配规则是：
                        1、其匹配的是同级同类型(type)元素标签，索引值针对的是匹配到的元素标签，冒号前的其他选择器是最后的过滤条件
                        2、匹配到多个不同元素标签时，将分别应用过滤条件确认匹配结果
                        例：
                        p:nth-of-type(2){ 匹配到同级p标签中第2个p标签 }
                        p.article:nth-of-type(2){ 先匹配到同级p标签中第2个p标签，再要求该p标签具有article类 }
                        .article:nth-of-type(2){ 没有指定元素标签，则通过article类先找到符合的元素标签，再从对应的元素标签中找第2个该标签，最后要求该元素具有article类；
                                                 若article类在相应位置找到多个标签，如假设在该位置p和span都具有article类，则这两个标签类型将各自继续按上面的方式匹配，
                                                 互不影响，相当于可以同时匹配到p.article:nth-of-type(2)和span.article:nth-of-type(2)}
        元素:nth-last-of-type(倒数第*个此元素){ 属性设置 }/*作用于包含此元素的所有块内的倒数第*个此元素，不考虑其他子元素的序列*/
        元素:first-of-type(第一个此元素){ 属性设置 }/*作用于包含此元素的所有块内的第一个此元素，不考虑其他子元素的序列*/

        目标伪类选择器：
        元素:checked{ 属性设置 }/*选中之后样式的变化*/
        input[type="text"]:disable{ 属性设置 }/*选中禁用的元素*/
        input[type="text"]:selection{ 属性设置 }/*选中时的元素样式设置*/
        input::selection{ 属性设置 }/*让input中所有选中的元素高亮，只能应用少量属性设置：color、background、cursor*/
        元素:not(简单选择器名){ 属性设置 }/*匹配所有此元素，除了包含此简单选择器名的此元素*/

        父元素~子元素{ 属性设置 }/*兄弟选择器，作用于哥哥之后的所有同级此子元素，哥哥本身不变*/
        父元素+子元素{ 属性设置 }/*CSS2中的相邻选择器，作用于哥哥之后紧邻的此子元素，哥哥本身不变*/
        父元素>子元素{ 属性设置 }/*后代选择器，只作用于父元素后第一代此子元素*/

        动效变化过渡设置：(对于两个状态只有设置了相同属性但不同值的部分才可实现过渡，即使是初始状态的默认属性要实现改变也要写出来)
        transition:all 0.5s linear (2s);/*三个值分别表示参与过渡的属性(宽高背景等、display不行)、过渡时间(ms、s)、过渡的类型、(延迟等待时间，可不设)，对多个属性设置时用逗号将每组数值隔开，all代表所有属性*/
        浏览器兼容：(Chrome)-webkit-transition:all 0.5s linear (2s);(FireFox)-moz-transition:all 0.5s linear (2s);(IE)-mst-transition:all 0.5s linear (2s);(Opera)-o-transition:all 0.5s linear (2s);
        transition是一个综合属性，包含以下四个子属性：
        transition-property：过渡属性名
        transition-duration：过渡时间
        transition-timing-function：过渡效果时间曲线
        transition-delay：过渡延迟时间(即等待多久再开始)

        盒子投影：box-shadow;5px 5px 10px (10px) gray (inset);/*四个值分别表示x轴偏移量(正值右偏、负值左偏)、y轴偏移量(正值下偏、负值上偏)、模糊度、（外延值，可不设）、投影颜色、(内部投影)，投影不占据实际空间，多层投影则每组值用逗号分开并换行*/
        文本投影：text-shadow:5px 5px 10px gray (inset);/*四个值分别表示x轴偏移量(正值右偏、负值左偏)、y轴偏移量(正值下偏、负值上偏)、模糊度、（无外延值）、投影颜色、(内部投影)*/
        input:focus{ 属性设置 }/*文本框点击时获得焦点*/

        background:red url("") left center no-repeat;/*简写形式，顺序：背景色、背景图片、水平位置、垂直位置、背景重复*/

        background-color:rgba(0,0,255,0.5);/*第四个值表示透明度，此处只是设置了背景色透明度，不影响盒子中的内容*/
        opacity:0.5;/*透明度，但此透明度是盒子内所有内容都要变化*/
        background:transparent;/*值transparent表示透明，类似于none，都不占据空间*/

        before/after插入的内容是内嵌的
        元素:before{/*插入在内容之前*/
                    content:插入内容;/*可添加文字(要加引号），特殊字符(\16进制unicode)，attr(title)(获取title中的内容)*/
                    其他属性设置
        }
        元素:after{/*插入在内容之后*/
                    content:插入内容;/*可添加文字(要加引号），特殊字符(\16进制unicode)，attr(属性名)(获取所选属性中的内容)*/
                    其他属性设置
        }
        <style>
            div:before{
                content:attr(title);/*获取title中的内容*/
                width: 50px;height: 50px;
            }
        </style>
        <body>
            <div title="鼠标移入时的提示文字"></div>
        </body>

        渐变：颜色可用16进制、rgb()、rgba()表示
        线性渐变：background-image:-webkit-linear-gradient(left,black,(more),red)/*线性渐变，括号内三个值分别表示渐变方向、起始颜色、(中间还可添加多个过渡颜色)、终止颜色*/
        background-image:-webkit-linear-gradient(0deg,black,(more),red)/*括号内三个值分别表示渐变开始的角度(deg表示单位度，左边默认为0度，逆时针旋转)、起始颜色、终止颜色*/
        background-image:-webkit-linear-gradient(0deg,black 40%,(more %),red 80%,blue 100%)/*其中的百分比%表示过渡的起始位置*/
        径向渐变：background-image:-webkit-radial-gradient(center,black 40%,(more %),red 80%,blue 100%)/*径向渐变，以中心向外辐射渐变，其中的百分比%表示过渡的起始位置*/

        变换：/*各变换可写在同一个 -webkit-transform后面，用空格隔开*/
        参考点：-webkit-transform-origin:left top;/*X轴/Y轴变换参考中心设置*/
        平移：
        -webkit-transform:translate(50px,40px);/*水平与垂直平移量*/
        -webkit-transform:translateX(50px);/*X轴平移量*/
        -webkit-transform:translateY(40px);/*Y轴平移量*/
        放缩;
        -webkit-transform:scale(2,3);/*宽和高分别放大或缩小为原来的倍数，注意它是以中心线为参考进行放缩的，大于1则为放大，小于1则为缩小，负值会发生翻转*/
        -webkit-transform:scaleX(2);/*X轴放缩倍数*/
        -webkit-transform:scaleY(3);/*Y轴放缩倍数*/
        扭曲：
        -webkit-transform:skew(30deg,60deg);/*X、Y轴扭曲角度*/
        -webkit-transform:skewX(30deg);/*X轴扭曲角度，类似于矩形变成平行四边形的变化过程*/
        -webkit-transform:skewY(60deg);/*Y轴扭曲角度*/
        2D旋转：
        -webkit-transform:rotate(60deg);/*2D旋转角度，正值顺时针旋转，负值逆时针旋转*/
        -webkit-transform:rotate(-60deg);/*2D旋转角度，正值顺时针旋转，负值逆时针旋转*/
        3D旋转：
        -webkit-transform:rotateX(180deg);/*绕X轴旋转角度，正值顺时针旋转，负值逆时针旋转*/
        -webkit-transform:rotateY(180deg);/*绕Y轴旋转角度，正值顺时针旋转，负值逆时针旋转*/

        -webkit-transform:matrix(1,0,0,1,50,0);/*矩阵式变换*/

        动画：
        1、定义动画规则：/*写在<style></style>内，name自取*/
        @-webkit-keyframes name{
            from{属性设置}
            to{属性设置}
        }/*可将from/to用百分比%来表示(0%、10%、50%、100%)，从而可设置整个过程中不同时段的动画效果(逐帧动画)*/
        2、调用动画规则：/*前三个值必须要有，后面的值为可选项，放在块内在页面加载时自动播放*/
        -webkit-animation:name 2s linear (1s) 3 forwards alternate;/*各值分别表示动画名、持续时间、动画过渡类型、(等待延迟时间)、动画播放次数(infinite为无限次)、动画完成时停留在结束位置还是回到起始位置(forwards为结束位置)、动画运动方向(alternate倒回)*/
        -webkit-animation-playstate:paused;/*动画暂停，可用于设置鼠标移入时*/

        自定义字体：/*放大不失真，适合响应式布局*/
        一、1、定义字体规则
        @font-face{
            font-family:"name自取";
            src:url(引入的字体文件1),/*ttf格式兼容性最好*/
                url(引入的字体文件2);
        }
        2、调用自定义字体
        font-family:"上面自取的字体name";/*调用时与设置系统自带字体时一样*/

        二、<link rel="stylesheet" href="css文件">


        媒体查询器：
        写于样式<style type="text/css"></style>中：
        @media screen and (min-width:1200px){ /*查询浏览器窗口屏幕，且其最小宽度为1200px时，即大于等于1200px时样式设置*/
            body{
                background-color:red;
            }
        }
        @media screen and (min-width:700px) and (max-width:1200px){ /*最小700px，最大1200px，即宽度在700-1200px之间时*/
            body{
                background-color:blue;
            }
        }
        @media screen and (max-width:700px){ /*最大700px，即宽度在700px以下时*/
            body{
                background-color:green;
            }
        }
        写于head中引用css文件：
        <link rel="stylesheet" href="css文件" media="screen and (min-width:700px)">

        背景图：
        background-size:cover;/*图像足够大，等比例放缩，占满盒子，图片超出部分不显示*/
        background-size:contain;/*满足背景图要全部显示完，还有多余则平铺补充*/
        background-size:50px 60px;/*设置背景图固定宽高*/
        background-size:50px;/*背景图固定宽度，高度则自适应*/
        background-size:20% 50%;/*按盒子比例设置背景图宽高*/
        background-attachment:fixed;/*背景图位置固定不动，不随滚动条移动*/

        边框转角处的绘制是45度平分的，可用于绘制三角形

        弹性盒模型：（设置父元素）
        display:flex;/*父元素设置此项后，里面包含的项目会水平显示，且不会发生父元素塌陷*/
        display:inline-lex;/*父元素设置此项后，容器会变成一个行内容器，所以其宽高就是其内容的宽高*/
        flex-direction:row;/*项目在一行显示，主轴在左边，从左往右排列*/
        flex-direction:row-reverse;/*项目在一行显示，主轴在右边，从右往左排列*/
        flex-direction:column;/*项目垂直排列，由上到下顺序，横向占据满屏*/
        flex-direction:column-reverse;/*项目垂直排列，由下到上倒序*/
        flex-wrap:nowrap;/*不换行，默认属性*/
        flex-wrap:wrap;/*正序换行，缩小浏览器窗口时会根据窗口大小自动将后面内容换至下一行*/
        flex-wrap:wrap-reverse;/*倒序换行，最前面的在排最下面*/
        flex-flow:row-reverse wrap;/*组合写法，第一个值为显示方向，第二个值为换行与否*/
        justify-content:flex-end;/*右对齐，相当于给列表项包了一个div并让它右浮*/
        justify-content:center;/*内容居中对齐，相当于给列表项包了一个div并让它margin:0 auto;居中*/
        justify-content:space-between;/*使各项目等间隔占满父元素，最左和最右与边框间不会出现相应间隔*/
        justify-content:space-around;/*使各项目等间隔占满父元素，同时最左和最右与边框间也会出现相应间隔*/
        纵向：
        align-items:stretch;/*默认值，列表项高度会自适应父元素高度*/
        align-items:flex-start;/*项目会靠着容器的最上面显示*/
        align-items:flex-end;/*项目会靠着容器的最下面显示*/
        align-items:center;/*项目会在纵轴的中间位置显示*/
        align-items:baseline;/*以文字基线对齐，项目中的内容会在一条线上显示*/
        align-content:flex-start;/*项目在容器的顶部开始显示，高度不会被拉伸*/
        align-content:flex-end;/*项目在容器的底部开始显示，高度不会被拉伸*/
        align-content:center;/*多行项目在容器的纵向中部显示，高度不会被拉伸*/
        align-content:space-between;/*多行项目在容器的纵向等距铺满显示，首尾与边框不会出现相应间隔*/
        align-content:space-around;/*多行项目在容器的纵向等距铺满显示，首尾与边框也会出现相应间隔*/
        排序：
        order:0;/*各项默认值都是0*/
        order:1;/*值越大则显示排列顺序越在后面*/
        order:-1;/*可为负值*/
        flex-grow:0;/*列表项默认宽度，即其内容宽度*/
        flex-grow:1;/*各列表项等宽度平分父元素总宽度，也可给某个列表项单独设置以放大，后面的数字代表几倍单位宽度，单位宽度由各数字和平分*/
        flex-basis：40px;/*设置各项初始宽度，也可为某一项单独设置*/
        flex-shrink:0;/*缩小设置，默认为0不缩小*/
        flex-shrink:1;/*缩小设置，缩小浏览器窗口时，列表项也会缩小，不能设置换行*/
        flex:0 1 auto;/*组合写法，三个值分别表示flex-grow、flex-shrink、flex-basis*/
        align-self:flex-start;/*自己在纵轴方向上的对齐方式，顶部*/
        align-self:flex-end;/*自己在纵轴方向上的对齐方式，底部*/
        align-self:center;/*自己在纵轴方向上的对齐方式，中部*/
        align-self:stretch;/*拉伸，适应父元素高度*/
        align-self:baseline;/*基线对齐，要有参考点*/



        JavaScript之ECMA：JavaScript注释单行用//，多行用/* * */，大小写敏感
        引入js文件方式：/*写在body结束标签</body>上一行*/
        一、<script type="text/javascript">js内容</script>
        二、<script type="text/javascript" src="js文件.js"></script>/*空内容*/
        三、通过元素的事件属性(on开头的属性名)<div onclick="写入js"></div>
        四、<a href="javascript:写入js代码">伪url的js</a>
        四、<a href="javascript:alert(代码)">伪url的js</a>

        JS定义变量：
        var myName;/*通过关键词var定义，逗号隔开可定义多个，变量名命名规则与前面一样，不可使用js保留关键词，大小写敏感，英文或_开头，中间可加数字，不可用其他特殊字符，驼峰命名法，见名知义，每条语句后加分号*/
        数据类型;alert弹出
        alert(typeof myName)/*弹出小窗(数据类型检测)，undefined，未定义型(默认型，因上面定义的变量后未赋任何值，若有赋值则会检测相应类型)*/
        myName=30;
        alert(typeof myName)/*number，数字型*/
        myName="3";
        alert(typeof myName)/*string，字符串型，要加引号，可为汉字*/
        myName=true;
        alert(typeof myName)/*boolean，布尔值型，true/false*/
        myName=null;
        alert(typeof myName)/*object，对象型，此处为空值空对象，null作占位用*/

        JS的输入/输出方式：
        输入：window.prompt("输入内容");/*myName=window.prompt("输入内容");输入的内容都是字符串类型*/
        输出：alert(输出内容+typeof myName);/*弹出小窗显示内容并显示myName的数据类型，加引号则为字符串，直接写数字则为number型，变量名不加引号，否则会当做字符串输出*/
              document.write("输出内容")/*直接输出显示在网页上，不弹出小窗*/
        确认与取消弹框：window.confirm("提示内容");<!--确认则返回true，取消则返回false-->
        parseInt(str,n);/*将字符串转换为整数，可选；从左到右解析直到遇到第一个非数字则停止，若开头就是非数字，则返回NaN，n为基数表示以几进制解析(注意是解析不是转换)，默认10进制*/
        parseFloat(myName);/*转换为浮点型数字，会保留一个小数点(不是一位小数)*/
        num.toFixed(n);/*将数字型变量num转换为十进制形式的字符串，可选参数n表示保留小数的位数，有效值在0-20间*/
        num.toString(n);/*可选参数n为2时，可将数字num转换为二进制字符串表示，num默认为10进制，括号中的参数有效值为2-36，表示转换为相应进制的字符串表示*/
        num.toExponential(n);/*此方法将num转换为指数表示字符串形式，可选参数n表示小数点精确位数，其有效值在0-20间*/
        num.toPrecision(n);/*此方法将num转换为十进制形式的字符串，可选参数n表示有效数字的位数，其有效值在0-21间，它会根据有效位数来决定显示成整数、小数、指数形式*/
        Number(myName);/*转换为数字型，先检查整个转换内容是不是一个纯数字，再进行转换，若不是纯数字则无法转换返回NaN，可以保留一个小数点*/

        运算：
        算数运算：+ - * / ，取模(余)：% ，取整：parseInt(5/2);

        关系运算符：>，<，>=，<=，= =(等于，只判断值)，= = =(全等/恒等，既判断值，也判断数据类型)，!=(不等)，!= =(不全等);/*结果返回布尔值true/false*/
        undefined= =null/*true，值相等*/
        undefined= = =null/*false，值相等，但数据类型不等*/
        0= =false/*true，但并不是真的相等，只是0在关系判断中可以自动转换成false*/
        ""= =false/*true，但并不是真的相等，只是""在关系判断中可以自动转换成false*/
        "0"= =false/*true，只判断值*/
        1= =true/*true，但并不是真的相等，只是1在关系判断中可以自动转换成false*/
        "1"= =true/*true，只判断值*/
        "2"= =true/*false，只判断值*/

        逻辑运算符：/*返回true/false*/
        && 与，|| 或，! 非
        var a="0";
        !a;/*false，字符串有值则为真，即使是"0","0"只有在关系判断中才会自动转换成false，逻辑运算中不会*/

        赋值运算符：
        =，+=，-=，*=，/= ;/*赋值，自加/减/乘/除，a+=5表示自加a=a+5*/

        增量++、减量- -：
        var a=5,b=10;
        b=a++;/*执行顺序：a先将值赋予b，a再自加1，结果返回a=6，b=5*/
        b=++a;/*执行顺序：a先自加1，a再将值赋予b，结果返回a=6，b=6*/
        a+=b;/*a=a+b，b值未变，返回结果a=15，b=10*/

        typeof运算符：数据类型判断
        instanceof运算符：a是否属于b的一个实例(返回true/false)，[1,2] instanceof Array  //true

        判断是否是NaN：/*NaN即Not a Number，意为不是一个数字*/
        var myName="adc";
        isNaN(myName);/*true*/

        var a="11";
        var b=2;
        alert(a+b);/*字符串拼接，会返回"112"*/
        alert(a-b);/*会返回9，都是数字时作减法会强制转换为数字类型，否则不可运算返回NaN*/
        alert("今天是愚人节"+4+1);/*返回今天是愚人节41,都是数字型时才是加法运算，一旦有字符串就是字符串拼接*/
        alert("今天是愚人节"+(4+1));/*返回今天是愚人节5，括号内单独运算*/
        a=a+1+5+2;
        a- -;
        alert(a);/*返回11151，number型*/
        a=String(a);/*强制转换成字符串*/

        特殊字符串：\n 换行，\b 空格，\r 回车，\\ 斜杠，\' 单引号，\" 双引号


        程序分支结构：条件判断
        单分支：if（条件表达式）{ 满足条件时的执行语句 }
        双分支：if（条件表达式）{ 满足条件时的执行语句 }
                else{ 不满足条件时的执行语句 }
        多分支1：if（条件表达式1）{ 满足条件1时的执行语句 }
                else if（条件表达式2）{ 不满足条件1，但满足条件2时的执行语句 }
                else if（条件表达式3）{ 不满足条件1、2，但满足条件3时的执行语句 }
                ......
                else{ 上面条件都不满足时的执行语句 }
        多分支2：switch（变量）{
                    case 值1:执行语句1;break;
                    case 值2:执行语句2;break;
                    case 值3:执行语句3;break;
                    ......
                    default:与上面的值都不相等时的执行语句;/*alert("请输入正确的数据");*/
                 }/*变量的值与下面case的值进行比较，注意比较方式是全等(值+数据类型)，与哪个值相等则执行对应语句，break是用于跳出当前语句，否则会从满足条件的语句处向后都执行*/


        循环结构：
        var i=1;/*变量申明并赋初值*/
        while(i<7){
            执行语句;
            i++;
        }
        do{ /*先执行一次，再进入循环*/
            执行语句;
            i++
        }while{i<7}/*再循环条件*/

        for( var i=1;i<7;i++){执行语句;}/*变量申明并赋初值；循环条件；变量累加规律*/
        break;/*跳出本层循环*/
        continue;/*跳出本次循环迭代*/

        遍历：
        for...in    //注意for...in亦会遍历到继承的属性或方法
        var arr1={height:"175cm",weight:"200kg",age:"15"};
        for(var i in arr1){
            // i 代表对象中的各属性或方法名，或数组中的下标(实际也是数组的属性名)
            console.log("i的内容："+i+"...某人："+arr1[i]);
        }

        var myArray=['yi','er','san','si'];
        //IE8及以下版本不支持forEach方法，且此遍历不支持continue和break跳出循环
        myArray.forEach(function(item){
            // item 代表数组中每一项的值
            if(item=="san"){
                return false;
            }else{
                console.log(item);
            }
        });


        原生对象1：
        数组Array：
        创建数组1：var name=new Array();//括号()中只有一个不加引号的数字时，此数字表示此数组的长度；几个数据用逗号隔开则存为数组内容，加引号也存为数组内容；name.length表示数组name的长度属性
        创建数组2：var name=[];//字面符形式创建，[]中添加数组内容,即使其中只有一个不加引号的数字时也是内容
        访问某个单元格：name[下标数] //下标数是从0开始的，也就是说name[0]表示数组name的第一个单元格
        数组是一个连续的储存空间，中间未定义的单元格在打印时内容是空的，并是用逗号隔开的

        尾部增加数组内容1：name.push(内容);//在数组name尾部增加内容，长度也会相应地增加
        尾部删除数组内容1：name.pop();//在数组name尾部删除一个单元格及其内容，长度也会相应地减少一个,括号()内不写内容
        头部增加数组内容1：name.unshift(内容);//在数组name头部增加内容，长度也会相应地增加
        头部删除数组内容1：name.shift();//在数组name头部删除一个单元格及其内容，长度也会相应地减少一个,括号()内不写内容
        删除数组内容2：name.splice(x,y);//从下标x处开始共删除y个单元格及其内容，长度也会相应地减少y个
        删增数组内容：name.splice(x,y,z);//从下标x处开始共删除y个单元格及其内容，并重新增加数据z，长度也会相应地变化
        增加数组内容2：name.splice(x,y,z);//将y设为0，则从下标x处开始，不删除内容，而重新增加数据z，长度也会相应地变化

        原生对象2：Math
        随机数：var name=Math.random();//默认0-1之间的随机数赋予变量name，Math.random()*10则是0-10之间的随机数，parseInt(Math.random()*10)则是0-10之间的随机整数，注意区间边缘的取舍情况
        四舍五入：var name=Math.round(x);//对x小数后一位进行四舍五入
        Math.floor(x);向下取整(只舍不进)；Math.ceil(x);向上取整(只进不舍)；Math.max(x,y);取最大值；Math.min(x,y);取最小值；更多内容自行拓展

        Date对象：
        var t=new Date();//获取系统当前的详细时间，包括年月日时分秒(英文格式)
        var str=name.toLocaleString();//此项可将上面获取的英文格式时间转换为本季语言(此处即中文)的时间显示格式
        var t= new Date(2001,0,7);//自行设置时间，顺序为年、月、日、小时、分钟、秒、毫秒，每个数据若超过其应有的范围，显示时会自动进位换算至对应的时间

        var name=t.getYear();//获取当前t的从1900到当前年份的距离
        var name=t.getFullYear();//获取当前t的具体年份
        var name=(t.getMonth()+1);//获取当前t的月份，因为其月份是从0开始算的，所以要+1
        var name=t.getDate();//获取当前t日期多少号
        var name=t.getDay();//获取当前t日期是星期几，0代表星期天
        var name=t.getHours();//获取当前t日期的小时数
        var name=t.getMinutes();//获取当前t日期的分钟数
        var name=t.getSeconds();//获取当前t日期的秒数
        var name=t.getTime();//获取当前t时间距离1970年1月1日午夜的毫秒数(前后皆可)
        ============================================================================================================
        new Date(xxxx,xx,xx)这个日期的构造方法有一个妙处，当你传入的是(xxxx,xx,0)（0号）的话，得到的日期是"xx"月的前一个月的最后一天，如果传入(1999,13,0)，会得到(1998,12,31)这个实际日期；
        而且最大的好处是当你传入(xxxx,3,0)，会得到xxxx年2月的最后一天，它会自动判断当年是否是闰年来返回28或29，所以，我们想得到某年某月有多少天的话，只需要
        var d=new Date(年,月,0);
        console.log(d.getDate());//得到当月最后一天，也即这个月的天数
        后面script里面自己写了一个函数来获取某年某月某日是星期几和当月的天数
        ============================================================================================================

        String对象：
        str.length;//获取字符串长度
        str.big();//字体变大
        str.small();//字体变小
        str.blod();//字体加粗
        str.italics();//斜体
        str.strike();//中划线
        str.fontsize(20);//字体大小，不带单位
        str.fontcolor("red");//字体颜色
        str.toLowerCase();//全部小写，()中不写内容
        str.toUpperCase();//全部大写，()中不写内容
        str.sub();//作为上标显示，()str容
        str.sup();//作为下标显示，()中不写内容
        str.link("url");//添加链接

        str.indexOf(str,from);//第一个值str为必需值，表示需要查找的指定的字符；第二个值为可选值，表示开始查找的位置，默认是从位置0开始查找；返回值为所查找字符第一次出现的位置，-1表示未找到
        str.match();//查找字符串中的指定字符，找到则返回该字符，未找到则返回null
        str.search();//返回指定字符的位置
        str.replace();//替换，replace("被替换字符","新字符");
        str.charAt(n);//返回n位置的字符
        str.substring(start,stop);//提取两个下标之间的字符，start为必需值，都为非负整数，start位置可取，stop位置字符取不到，若start>stop则会自动调整换位，此方法不会改变原数组
        str.substr(start,n);//返回从开始位置起共n个字符，只有一个值时则返回其后所有字符，start可为负值表倒数共几个，此时无n值，此方法不会改变原数组
        str.trim();//去掉字符串左右两边的空格(原生JS中并无此方法)；部分浏览器不支持此方法(如IE8及以下);要兼容可用正则自定义一个trim函数：str.replace(/^\s+|\s+$/g,"");'
        str.split("|",n);//把一个字符串以指定的符号为界分割成字符串数组，第一个值(必需)为分割字符串的标示(若字符串中无此符号，则会将此字符串整体当作一个单元格)，第二个值(可选)表示返回的数组长度

        str.slice(start,end);//与substring类似，只是可以为负值，此时就表示倒序查找，同样不包括结束位置，此方法不会改变原字符串或原数组；[].slice.apply(argments)可用于将伪数组转换为标准数组
        str1.concat(str2);//字符串或数组拼接，将str1内容与str2内容拼接在一起，数组arr内容也可直接[1,2,3]形式写出；数组与字符串可混合拼接，结果数据类型以name1为准，字符串后拼接数组时，[]会去除，但分隔数据的,会以字符串形式保留下来




        函数function：
        定义函数：function name(形参1,形参2,...){ 执行语句 }//定义时函数不会执行语句，只有调用时才执行此函数；return返回某个结果给函数，且其后面的语句不再执行，返回的结果只有一个，要返回多个结果可将各不同结果存在一个数组的不同单元格中，然后返回此数组取出各数据就可；若未给函数设定返回值，则执行结果是undefined
        调用函数：name(实参1,实参2,...);//无参数时括号()仍不能省，onlick="name()"鼠标点击时调用此函数



        DOM：
        文档流节点操作：//有()表示方法，无()表示属性，document是从最外围的文档流开始寻找，也可直接从某个父元素处开始，此时就要替换为此父元素名
        查询是否有子节点：document.body.hasChildNodes();//查询body下是否有子节点，返回true或false
        var n=document.body.childNodes;//返回body下的节点，类似数组，可通过下标访问，length表节点个数

        document.body.n[i].nodeName;//body下的第i个节点的类型名
        nodeName所返回的类型名有：1、Element 元素节点（标签名、script）；2、Attr 属性节点；3、#text 文本节点（除文本外的换行也算一个节点）

        document.body.n[i].nodeType;//body下的第i个节点的类型
        1代表元素节点，2代表属性节点，3代表文本节点

        document.body.n[i].nodeValue;//body下的第i个节点的值
        1元素节点的值nodeValue=null；2属性节点的值nodeValue=属性的值；3文本节点的值nodeValue="文本内容"

        节点的定位寻找：
        下一个兄弟节点：n[i].nextSibling;//n中第i个节点的下一个节点
        上一个兄弟节点：n[i].previousSibling;//n中第i个节点的上一个节点
        第一个节点：document.body.firstChild;//body下第一个节点
        最后一个节点：document.body.lastChild;//body下最后一个节点
        通过Id获取节点：document.getElementById("id名");//getElementById只能在document下使用，而getElementByClassName、getElementByTagName、getElementByName可在其他节点下使用
        通过Class获取节点：var1=document.getElementsByClassName("class名");//通过class访问节点，即使同样的class类只有一个，返回的值var1也是一个集合collection，类似一个数组，都要再通过下标访问相应的class位置(只有一个时也要用var1[0])
        通过标签名获取节点：var2=document.getElementsByTagName("标签名");//通过标签名访问节点，特别注意其会获取节点下所有级别的此标签，即使同样的标签只有一个，返回的值var2也是一个集合collection，类似一个数组，都要再通过下标访问相应的位置(只有一个时也要用var2[0])
        通过属性名获取节点：var3=document.getElementsByName("属性名");//通过属性名访问节点，即使具有同样属性名的标签只有一个，返回的值var3也是一个集合collection，类似一个数组，都要再通过下标访问相应的位置(只有一个时也要用var3[0])

        通过CSS选择器获取节点：querySelector和querySelectorAll IE8+浏览器支持；querySelector只返回匹配到的第一个DOM元素，而querySelectorAll返回一个NodeList(节点列表，一个伪数组，即匹配到的所有节点)
        一般使用document.querySelectorAll()较多，但也支持node.querySelectorAll()(此时会从node节点本身找起，而不是node的子节点找起，区别于jQuery中的find方法)，可参考：http://www.zhangxinxu.com/wordpress/2015/11/know-dom-queryselectorall/
        语法：document.querySelectorAll("css选择器")：querySelectorAll("#id")，querySelectorAll(".class")，querySelectorAll("p")，querySelectorAll("div p")；

        移动节点：父节点.appendChild(子节点);//将子节点整部分(包括内容)全部剪切到父节点中
        创建节点：document.createElement("p");//在document下创建一个p标签的元素节点
                  document.createTextNode("文本内容");//在document下创建一个有内容的文本节点，通过创建和移动节点可实现复制节点
        删除节点：父节点.removeChild(子节点);//删除父节点中的某子节点
        替换节点：父节点.replaceChild(新节点,被替换子节点);//在此前要先创建新节点
        插入节点：父节点.insertBefore(新节点,位置节点);//在指定位置前插入节点
        复制节点：被复制节点.cloneNode(true/false);//设为true时复制节点及其所有内容，设为false时只复制节点，不复制其内容

        节点.tagName;//返回该节点的标签名
        节点.childNodes;//指向此节点的子节点，返回一个集合
        节点.parentNode;//指向此节点的父节点，只有一个，非集合
        节点.getAttribute("属性名");//获取节点处的某属性的值
        节点.setAttribute("属性名","属性值1 属性值2");//设置节点处的某属性的属性值，多个值用空格隔开
        节点.removeAttribute("属性名");//删除节点处的相应属性
        节点.innerHTML="内容";//在节点处添加内容，同时支持插入标签，添加时会清空此节点下的所有内容，要在原基础上添加则应写成：节点.innerHTML=节点.innerHTML+"添加内容";
        节点.innerText="文本";//在节点处添加文本内容，不支持插入标签（会被当作字符），innerHTML与innerText同时出现时按代码顺序只显示后面一个
        innerHTML和innerText既可添加内容，也可获取内容，注意innerText只获取文本内容，包括其子节点中的文本(标签直接被过滤)；
        textContent属性与innerText作用一样，只是textContent要IE9+才支持；
        清除前面节点方法：1、循环时在执行语句中添加i- -；2、节点.length=0；3、节点.innerHTML="";
        this是把自己整个节点作为实参，把自己传出去（this.属性，则表示本身的某个属性的值）

        table表格操作：获取input的值通过value来实现
        增加表格的行：节点.insertRow(i);//i表示从第几行开始增加，从0算起
        删除表格的行：节点.deleteRow(i);//i表示删除第几行
        增加表格的列：节点.insertCell(i);
        删除表格的列：节点.deleteCell(i);

        CSS样式操作：//注意通过JS修改CSS样式时，其属性的书写格式与直接在CSS中写的格式略有区别(无间隔线-，有大小写变化)，且JS是将其添加成行间样式
        背景色：节点.style.backgroundColor="red";//设置节点处的背景色，var clo=节点.style.backgroundColor则表示获取节点处的背景色值(注意此处也是获取的行间处)
                //注意：若后面的颜色是用的16进制表示，那么浏览器在设置时是将其转换成rgb()格式的，并且第2、3个值前要加一个空格，若要获取它进行后续判断则需要特别注意此处
        设置margin等带单位的样式时要将获取的样式原属性值转换为整型parseInt()(因通过JS获取的其属性值带单位，所以不能直接转换为数字Number型)再加上其他数字，单位要最后单独加引号""
        节点.currentStyle.属性;//这是IE下获取最终样式，不一定是行间，最后显示的是哪个，就获取的是哪个，即优先级最高的那个(DOM浏览器是另外的)
        var sht=document.styleSheets[i];//获取外部第i个样式表
        sht.rules[j].style.属性="值";//获取sht下第j个规则(即其中第j个花括号{}包含的样式)的某属性
        节点.style.cssText="width:300px;height:300px";//在行间重置样式
        节点.style.cssText="background:deeppink";//会造成覆盖，前面设置的宽高会被清除，因为是重置，就像innerHTML一样会全部改写为现在的内容

        事件event：//注意事件的冒泡机制：IE中先从最精准的元素开始，逐渐往上级触发相关事件，直到具有相关事件的最外围；而网景的事件捕获则刚好相反
        事件的指派方式：//注意事件的取消写法要与设置时一样才会起作用
        1、传统指派方式1：直接在标签中通过以on开头的事件属性去调用函数；//优点是兼容性好，IE5也可兼容
           传统指派方式2：通过JS获取节点再添加事件属性赋予函数；//节点.onclick=functionname;，注意此种方式将函数赋予事件时不能加括号()，若加了()函数将在页面加载时直接执行，而不会触发该事件时才执行
                          //上面的传统指派方式2中函数不能传参，若要传参则需要给事件赋予一个匿名函数：节点.onclick=function(){实际要调用的函数(加括号)}
                          //若要取消前面设置的事件，则可给事件赋予null值：节点.onclick=null;
        2、现代指派方式：事件绑定：
                            DOM浏览器中：设置事件：节点.addEventListener("click",functionname,false);//值1为要绑定的事件类型(去掉on)，值2为处理程序(函数，要去掉括号())，值3为布尔值(true为事件捕获机制，false为事件冒泡机制，省略则默认false)
                                             传参：节点.addEventListener("click",varname,false);//匿名函数传参，但此时要将匿名函数赋给一个变量var varname=function(){实际要调用的函数(加括号)}
                                         取消事件：节点.removeEventListener("click",functionname,false);//值1为要绑定的事件类型(去掉on)，值2为处理程序(函数，要去掉括号()，有传参时值2则为varname)，值3为布尔值(true有事件捕获机制，false为事件冒泡机制，一般用false)
                            IE浏览器中：设置事件：节点.attachEvent("onclick",functionname);//只有2个值，且值1要加上on，因是IE自己提出的，默认就是冒泡，所以无第3个值
                                            传参：节点.attachEvent("onclick",varname);//传参方式与DOM浏览器一样
                                        取消事件：节点.detachEvent("onclick",functionname);//只有2个值，且值1要加上on，有传参时值2则为varname
                            兼容DOM 跟IE的现代指派：var btn4=document.getElementById("btn4");
                                                    jianrong(btn4,"click","onclick",myEv2)
                                                    function jianrong(obj,env1,env2,myevent){
                                                        if(obj.addEventListener){
                                                            obj.addEventListener(env1,myevent,false)
                                                        }else if(obj.attachEvent){
                                                            obj.attachEvent(env2,myevent)
                                                        }
                                                    }
        现代与传统指派的区别：现代指派同一事件可以绑定多个事件处理程序(即函数)，而传统指派的事件只能绑定一个事件处理程序，前面的会被覆盖
        阻止事件冒泡机制：var en=window.event||arguments[0];//获取event对象的相关信息
                         DOM中：en.stopPropagation();
                         IE中：en.cancelBubble=true;
        阻止默认事件：阻止a标签的默认点击跳转页面1、<a href="综合笔记.html" onclick="return window.confirm('你确定要跳转嘛？')">跳转页面</a>
                                                 2、<a href="综合笔记.html" onclick="return false">跳转页面</a>
                                                 3、<a href="综合笔记.html" onclick="return tiao()">跳转页面</a>
                                                    function tiao(){return false;}
                                                 4、<a href="综合笔记.html">跳转页面</a>
                                                    var em=document.getElemenetByTagName("a")[1];
                                                    em.onclick="return false";//也可用此法调用函数来解决
                     阻止submit按钮提交：与a标签类似
        var e=window.event||arguments[0];//获取event对象的相关信息
        e.type;//获取事件类型
        e.clientX;//获取鼠标点击位置相对页面(或浏览器窗口)的X轴坐标
        e.clientY;//获取鼠标点击位置相对页面(或浏览器窗口)的Y轴坐标
        e.screenX;//获取鼠标点击位置相对电脑屏幕的X轴坐标
        e.screenY;//获取鼠标点击位置相对电脑屏幕的Y轴坐标
        e.target;//DOM中返回触发此事件的事件源(即设置此事件的标签名)
        e.srcElement;//IE中返回触发此事件的事件源(即设置此事件的标签名)
        e.keyCode;//获取键盘上某按键的实际物理编码，DOM和IE都可用，键盘事件：onkeydown为任意按键按下，onkeypress为任意可打印字符按键从按下到弹起，onkeyup为任意按键弹起(事件触发也依此顺序，不管他们在代码中写的顺序)
        e.charCode;//获取键盘上某按键(按下能打印出上面字符的按键)的字符编码，用onkeypress它都返回字符编码，在DOM中用onkeydown和onkeyup它都返回0，IE中用onkeydown和onkeyup它都返回undefined
        e中还有这么几个属性：ctrlKey（metaKey）、altKey、shiftKey，当你同时按下组合键的时候，这几个属性会变成true，所以组合键就可以通过监听按键code和这几个属性的状态进行判断了
        String.fromCharCode(keycode值);//由键盘码找到对应字符
        对于鼠标🖱点击事件 e.button 可返回对应的鼠标键，0表示左键、1表示中键、2表示右键，但IE8下却分别是1、4、2对应左中右
        常见鼠标事件：onmousedown，onmouseup，onmouseover，onmouseout，onmouseenter，onmouseleave，onclick，ondblclick，onmousemove，onmousewheel(Firefox下鼠标滚动是监听DOMMouseScroll)
                    注意：
                    onmouseover 与 onmouseenter 的区别：over是鼠标从其他元素上面移到事件元素身上就触发(是直接身上，所以鼠标在其子元素上面时表明已out)，而enter是鼠标进入事件元素的边界时触发(内部子元素也在边界内，所以不会多次触发)
                    onmouseout 与 onmouseleave 的区别：onmouseout为鼠标移出事件元素身上，对应onmouseover，而onmouseleave为鼠标离开事件元素边界，对应onmouseenter
                    CSS中的hover伪类效果对应的实际就是 onmouseenter 和 onmouseleave，即其将事件元素和其子元素看作一个整体，而 onmouseover 和 onmouseout 是把事件元素和其子元素区分开的
        常见HTML事件：onfocus(获得焦点)、onblur(失去焦点)

        对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：
        window.innerHeight;//浏览器窗口的内部高度
        window.innerWidth;// 浏览器窗口的内部宽度

        对于 Internet Explorer 8、7、6、5：
        document.documentElement.clientWidth;//获取浏览器页面宽度
        document.documentElement.clientHeight;//获取浏览器页面高度
        或者：
        document.body.clientHeight
        document.body.clientWidth

        实用的 JavaScript 方案（涵盖所有浏览器）：
        var w=window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        var h=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;


BOM：前面的window可省略
        窗口操作：window.prompt("请输入");//输入框，确定会返回输入内容，取消会返回null
                  window.conform("确定/取消？");//确认框，确定返回true，取消会返回false
                  alert("警告");//警告框，返回undefined，前面也可加上window
                  window.screen.width;//获取电脑屏幕横向分辨率，无单位
                  window.screen.height;//获取电脑屏幕纵向分辨率，无单位
                  window.location.href="url";//页面跳转，默认在当前页面打开
                  window.location.reload();//刷新当前页面，相当于按下F5
                  window.open("url","newwindow","width=200,height=200,screenX=200,,screenY=200");//在新窗口打开，三个引号内的值分别是URL、新窗口、新窗口的宽高位置等属性，数值都无单位
                  window.history.back();//返回历史记录中的上一页
                  window.history.forward();//前往历史记录中的下一页
                  window.history.go(-1/1/0);//前往历史记录中的页面，-1表示返回上一页，1表示下一页,0则表示刷新当前页面
                  window.navigator.userAgent;//navigator对象获取当前浏览器的详细信息(版本等各种信息)，其下还有很多属性，userAgent是其最常用的一个属性
                  setTimeout("执行程序",等待毫秒时间(无单位));//定时器，只会执行一次，执行程序是一个函数时可写成"functionname()"加引号和括号，也可写成functionname不加引号和括号
                  clearTimeout(set);//取消定时器，注意此处要将前面设置的定时器赋给一个变量，通过变量来清除set=setTimeout("执行程序",毫秒时间);变量要设为全局变量var set；
                  setInterval("执行程序",间隔毫秒时间);//重复执行
                  clearInterval(set);//清除重复执行，注意此处也要跟clearTimeout一样通过变量来清除

                  window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;//获取滚动条到顶部的距离(无单位)，也可对其进行赋值设置，同理有 scrollLeft 属性，window对象上则对应pageXOffset（只读，IE9+）
                  console.log(window.scrollY);//在控制台中显示滚动条的Y轴坐标
                  window.scrollTo(0,window.scrollY-10);//通过scrollTo只能设置(不能获取，此处获取是用window.scrollY)滚动条到顶部的距离，第一个值为X轴距离，第二个值为Y轴的值
                  节点.offsetLeft;//节点所在块距离其最近定位祖先节点offsetParent左边的距离(无单位)，offsetTop距离顶部，只可读不可设

        模拟事件：//此处为模拟鼠标事件，注意模拟不加on，可表示对节点处之前的相关事件进行调用，也可直接为节点处设置一个事件属性，如节点.focus()设置自动获取焦点
            节点.click();
            节点.dblclick();
            节点.mousedown();
            节点.mouseup();
            节点.mouseover();
            节点.mouseout();


        表单form元素控制：

        required="required";//输入型表单控件的一个表示为必填项的属性，若未填写就进行提交会弹出提示框
        属性placeholder="提示信息"//与value不同的是它不会成为输入框控件的起始显示内容，它只显示，不会成为内容
        定位寻找form：
            1、通过id、class查找
            2、var var1=window.document.forms[i];
            3、var var2=document.forms["formname"];//为表单取名name="formname"，则可通过表单名查找，注意表单名像id一样是唯一的
            4、var var3=document.formname;//为表单取名name="formname"，则可通过表单名查找，注意表单名像id一样是唯一的

        访问表单域(表单内的表单控件，不包含非表单控件的标签)：
            1、表单节点.elements[i];//表单中的第i个控件
            2、表单节点.length;//返回表单长度(即其中表单控件的个数)
            3、表单节点.elements["控件name"];//为控件取名name="";
            4、表单节点.控件name;//为控件取名name="";
            5、表单节点.id名;
            6、表单节点[控件name];//为控件取名name=""，名字中可以有空格

        表单节点.focus();//模拟focus事件，可让控件自动获得焦点，blur失去焦点
        表单节点.submit();//模拟submit事件，可让普通控件具备submit功能(即具有实际数据提交功能)
        表单节点.reset();//模拟reset事件，可让普通按钮控件具备reset功能(重置功能)
        表单节点.select();//模拟select事件，可让普通文本输入控件的内容在一加载时就被选中
        在行间添加onselect事件可设置当文本输入型控件内容有被选中时执行的语句
        disabled属性表示禁用，禁用后无法修改，也无法提交已有内容，readonly为只读，不可修改内容，但已有内容仍可提交
        节点.removeAttribute("属性名");//删除节点处的相应属性
        select控件节点.option[i].text //获取下拉列表select控件下第i个option选项中的文本内容
        select控件节点.option[i].value //获取下拉列表select控件下第i个option选项的value值，注意选项内容不是value
        select控件节点.value //下拉列表select控件的value值是被选中的option的value值
        select控件节点.selectedIndex //获取下拉列表select控件下被选中选项option的下标
        select控件节点.remove(select控件节点.selectedIndex);//删除当前选中的option选项，通过下标selectedIndex来找到当前下拉列表select控件下被选中选项option的下标
        select控件节点.option[select控件节点.selectedIndex]=null;//因返回的option是个集合，可通过对应下标将其赋空null来达到删除此项的目的
        限制输入字符长度最好用maxlength属性


        正则表达式：

        声明正则规则：
            1、通过对象声明var var1=new RegExp();
            2、通过字面量形式声明var var1=/规则/;

        简单规则：
            /*元字符
            * 1直接写入字符串
            * 2 [] 方括号内的任意字符  一组中的一个
            * 3 \w  跟[a-zA-Z0-9]一样
            * 4 \d  等于[0-9] 数字0-9
            * 5 \s  空白 换行，制表符，回车
            * 6 .除换行和其他Unicode行终止符之外的任意字符
            * */

            /*锚字符
            * ^ 匹配开头，
            * $ 匹配结束
            * */

            /*数量
            *{n}  代表n个
            * {n,}  至少两个
            * {n,m} 代表 至少n个 ，最多m个
            * +  >=1个
            *    * 0||>0个
            *    ?  0个或者1个
            * */

            /*修饰符  写在斜杠外
            * i  不区分大小写
            * g  全局查找
            * m  换行查找
            * */


        html5中data-自定义属性(IE11+才支持dataset API)：一个元素上可以设置任意多个data-自定义属性，一般都是用来存储简单数据方便使用(或者用于CSS属性选择器)；
        data-自定义属性的存取：
        1、利用 getAttribute、setAttribute 存取 dataset，此法所做出的任何更改，都是可以实时反映到元素data-属性上的，但此方法每次执行只能获取或设置一个属性。
                获取：document.getElementById("idName").getAttribute("data-属性");
                设置：document.getElementById("idName").setAttribute("data-属性","属性值");
        2、利用 jQuery中attr 方法存取 dataset，用法与元素其他自带属性一样，并且所做出的任何更改，也都是可以实时反映到元素data-属性上的。
        3、利用 dataset API 存取 dataset，此法可方便地获取元素的所有data字段，并以对象的方式返回，方便存取和遍历，所做出的任何更改，也都是可以实时反映到元素data-属性上的。
                获取对象：var dataObj = document.getElementById("idName").dataset; //以对象形式返回该元素上的所有data-属性
                存取属性：dataObj.name;  //存取方法与对象中的属性一样，注意用此法存取时不加data-前缀，直接是后面的name，若name中带有连字符-，则用驼峰命名方式访问。
        4、利用 jQuery中data 方法存取 dataset，注意用此法存取时也是不加data-前缀的，而且此法对data数据做出的更改，不会反映到HTML元素data属性上，而只是保存在jQuery对象中。
                获取：obj.data("name");
                设置：obj.data("name","value");  //此时该jQuery对象中的该name属性值已改变，但是该元素对应的html文档中的data-name属性值并未变，若采用上面其他方法访问得到的将仍是原来的属性值，而obj.data方法可以获取到现在的值
                另外jQuery中data方法可以解析元素上dataset的JSON信息：其可以很聪明的从data里提取出json信息转换为对象，例如：
                    HTML：<span id="song-info" data-meta='{"name":"Latch", "album":"Disclosure", "date":"2013"}'>Latch (feat. Sam Smith)</span>
                    JS：var songInfo = $("#song-info").data("meta"); //将data-meta属性的JSON格式值转化为对象形式返回
                        songInfo.date;  //此时可通过对象的形式进行访问


    </div>
    <script>
        // 获取某年某月某日是星期几和当月的天数(传入年月或年月日)
        function getDaysOfMonth(year,month,day){
            var daysOfMonth = new Date(year,month,0).getDate();//当月天数
            var date = null,week = null;
            if(day>0&&day<=daysOfMonth){
                date = new Date(year,month-1,day);
                week = date.getDay();//所给日期是周几
            }
            var time = {
                date: date,
                days: daysOfMonth,
                week: week
            };
            return time;
        }
    </script>

    <!--*********************************************************************************************************-->
    <!--********************************************* 第三部分start *********************************************-->
    <!--*********************************************************************************************************-->
    <div>
        数据库：数据组织、存储、管理的仓库
        数据库模型：层次(树状)模型、网状模型、关系模型、对象模型、半结构化
        DB：database，数据库
        RDB：Relational Database，关系数据库
        DBMS：(Database Management System，数据库管理系统
        RDBMS：Relational Database Management System，关系数据库管理系统
        MySQL：关系数据库管理系统，SQL server家族，Oracle，db2，sybase，MySQL。
        table：表。表是数据库的核心单元。
        行，是所有记录的名称，表示一个真实的实体。列，是行的一个数据域，也就是实体的一个属性。
        多行、多列构成了表。多表构成了数据库。
        主键：是一行数据唯一的区别。
        外键：在数据库设计时。从表中的外键需要与主表中的主键进行关联
        SQL：Structured Query Language，结构化查询语言，它是一种非过程式语言，只关心结果，不能独立开发成应用程序，只能通过宿主语言来执行SQL语句后实现应用程序的开发。如在JAVA/PHP/C++/JS等语言中
        必须掌握的三种SQL语言：DDL(Data Definition Language)数据定义语言，DML(data manipulation language)数据操作语言，DQL(Data QueryLanguage)数据查询语言，另外有DCL(Data Control Language)数据控制语言，TPL事务处理语言，CCL指针控制语言
        多对多关系至少需要三个表

        SQLyog中单行注释用- -，多行注释用/**/
        CREATE DATABASE 数据库名 <!--创建数据库-->
        USE 数据库名<!--连接使用数据库-->
        DROP DATABASE 数据库名<!--删除数据库-->
        数据库命名首字母只能是英文，_，@，#；后面可用数字、字母、@、#；不可用保留字和SQL语言中的关键字
        CREATE TABLE 表名(字段名1 数据类型(长度) 约束，字段名2 数据类型(长度) 约束...) <!--创建表-->
        表名：以数据库的首字符开始，后加下划线，再加表名；如库名：baijie94，表名：b_student，列名：s_name
        CREATE TABLE b_student(
        s_id INT PRIMARY KEY,<!--定义主键约束：primary key-->
        s_name CHAR(50) UNIQUE,<!--定义唯一约束：unique-->
        s_age DECIMAL(5,2),<!--数据类型DECIMAL(m,n),m表示数字总位数，n表示其中小数占的位数-->
        s_birthday DATA    <!--最后一个结尾不打逗号,-->
        )
        数据类型：
        字符串型：char，固定长度；varchar，不固定长度，即使不输入数据，长度也是1，输入数据则依次+1
        文本型：text，大文本
        CREATE TABLE 表名2 SELECT * FROM 表名1<!--备份表数据，将表1数据备份到表2中-->

        实体完整性：
        主键约束：非空，且具有唯一性
        唯一约束：不可重复，可以为空NULL，但NULL也只能出现一次

        域完整性：
        非空约束：NOT NULL
        默认约束：DEFAULT
        检查约束：CHECK   <!--MySQL中，它总是分析CHECK约束，但是会忽略CHECK约束-->

        引用完整性：

        删除表：DROP TABLE 表名

        自动增长列：AUTO_INCREMENT(适用于INT型，但它不受删除行的影响，只会+1，不会因删除自动-1)
        也可通过修改表的方式来设置ALTER TABLE 表名 AUTO_INCREMENT=起始数

        复制表结构：CREATE TABLE 表名2 SELECT * FROM 表名1 WHERE 1=0
        复制表结构和数据：CREATE TABLE 表名2 SELECT * FROM 表名1   <!--注意着两种都不会复制约束(索引)-->

        添加字段列：ALTER TABLE 表名 ADD COLUMN 添加的字段及约束
        删除字段列：ALTER TABLE 表名 DROP COLUMN 添加的字段及约束
        修改字段列：ALTER TABLE 表名 CHANGE 被修改的字段 新的字段及约束

        DML
        数据的插入：insert into 表名(要插入的字段列表名)values(值1，值2，...)
        自动增长列，默认值列，单条数据的插入，多条数据的插入

        单条数据的全字段插入(此时最好取消自动增长列)：INSERT INTO 表名(要插入的字段列表名)values(值1，值2，...)<!--值为字符串时要用单引号引起来-->
        如果表中的列允许为NULL值，则在插入数据时，可以不指定该数据列

        多条数据的插入：INSERT INTO 表名(要插入的字段列表名)values(值1),(值2),(值3)...<!--只能在MySQL中这样使用，注意只能有一个values-->
        通过查询来插入多条数据：INSERT INTO 表名2 SELECT * FROM 表名1  <!--不加values-->

        UPDATE 修改、更新数据列：
        基本语法：UPDATE 表名 SET 字段名1=值1,字段名2=值2,...WHERE 条件表达式  <!--若未加条件，则修改所有行的对应字段-->
        UPDATE 表名 SET 字段名=NULL WHERE 条件表达式  <!--让满足条件的行中的某字段为空，即可表示删除该字段数据，但首先要允许此字段为NULL-->

        DELETE FROM 删除表：
        DELETE FROM 表名 <!--只删除行的数据，表的结构还在-->
        DELETE FROM 表名 WHERE 条件表达式 <!--删除满足条件的行-->

        <!--DELETE会记录日志，意味着数据删除后还可恢复，但效率低；TRUNCATE不会记录日志，意味着删除后不可恢复，但效率高-->
        TRUNCATE TABLE 表名<!--删除-->


        DQL语言：SELECT语句执行查询
        基本语法：SELECT [DISTINCT] {*|字段名[别名],...} FROM 表名 [WHERE 过滤条件] [ORDER BY 字段1,字段2...]
        <!--投影操作，投影到虚拟表-->
        USE 库名<!--选择要使用的数据库-->
        SELECT * FROM 表名 <!--先执行from，将标加载到内存，接着执行投影操作，确定要投影的字段列表-->
        SELECT 字段名 FROM 表名 <!--查询单个字段-->
        SELECT 字段名1,字段名2,... FROM 表名 <!--查询多个字段，各字段用逗号隔开-->

        表的别名、列的别名：
        方式1：SELECT 字段名 AS 别名(可为汉字)
        方式2：字段名1 '别名1',字段2 '别名2',...<!--别名一般需要用单引号引起来，特别是名称中有空格分隔的情况-->

        返回表中的唯一的数据值(即有重复的值只返回一个)：DISTINCT <!--如查询班级学生所有性别SELECT DISTINCT s_sex FROM stu，显示班上所有的年龄段SELECT DISTINCT s_age AS '年龄段' FROM stu-->

        显示指定行数的数据：limit(放在语句的最后位置)
        语法：limit 起始行位置，行数<!--此项要放在语句的最后位置，如显示前五个学生的信息SELECT * FROM stu LIMIT 0,5 (下标从0开始)-->
        若只有一个参数，则此参数表示行数，起始行默认为0

        SELECT s_age+10 AS 年龄 FROM stu <!--所有学生年龄+10，并以别名显示(否则会显示成s_age+10)-->
        SELECT CONCAT(s_name,"/",s_age) AS "姓名/年龄" FROM stu<!--concat()字符串连接函数，用于字符串拼接-->

        <!--选择操作 WHERE 过滤条件-->
        SELECT * FROM 表名 WHERE 过滤条件
        条件中可用 between and 表示闭区间范围，AND表并且，OR表或者
        IN(或者连接同字段多条件，表满足这些条件之一，逗号隔开)，NOT IN(并且连接同字段多条件，表不满足这些所有条件，逗号隔开)
        <!--SELECT * FROM stu WHERE s_age IN(21,23,25,28)；SELECT * FROM stu WHERE s_age NOT IN(21,23,25,28)-->

        模糊查询：like 通配符
        通配符："_"，表示匹配1个字符长度的字符
        "%"，表示匹配0个或任意个字符长度的字符
        <!--显示姓名中第二2个字是“红”的记录SELECT * FROM stu WHERE s_name LIKE "_红%"-->
        <!--显示姓名中有个字是“强”的记录SELECT * FROM stu WHERE s_name LIKE "%强%"-->
        <!--显示三个字姓名中间字是“德”的记录SELECT * FROM stu WHERE s_name LIKE "_德_"-->
        NULL值的判断：is null，is not null<!--显示所有已报到的学生记录SELECT * FROM stu WHERE s_name IS NOT NULL-->

        排序操作：order by 子句
        SELECT s_name,s_age FROM stu
        ORDER BY s_age ASC <!--按年龄从小到大显示所有学生的姓名和年龄，ASC表升序，DESC表降序，默认排序为升序-->
        <!--将中文字按拼音排序convert(参与排序的字段名称 using 编码名称)，utf-8编码不能按拼音顺序排列-->
        SELECT s_name FROM stu
        ORDER BY CONVERT(s_name USING gbk/gb2312) <!--将姓名按拼音顺序排列-->


        使用SELECT来执行聚合函数

        COUNT：统计行数；结构：SELECT COUNT(计数规范) FROM 表名
        SELECT COUNT(*) FROM stu <!--对所有行进行统计，包括为null值的行-->
        SELECT COUNT(ALL s_name) FROM stu <!--ALL可省略，对所有有名字的(非null)行进行统计，这就包括为null值的行-->
        SELECT COUNT(DISTINCT c_name) AS 班级数 FROM stu <!--统计班级数，重复的值只返回一个-->
        SELECT COUNT(*) FROM stu WHERE s_sex='男' <!--统计男生数-->

        SUM：求和；结构：SELECT SUM(计数规范) FROM 表名
        SELECT SUM(ALL s_score) 总分 FROM score <!--ALL可省略-->
        SELECT SUM(DISTINCT s_score) 总分 FROM score <!--重复的值只返回一个-->
        ifNULL(字段名,0)<!--如果为空则此字段名返回0-->
        SELECT SUM(ifNULL(s_score,0)) 总分 FROM score<!--s_score为null的项则认为其s_score值为0-->

        AVG：求平均值；结构：SELECT AVG(计数规范) FROM 表名
        SELECT AVG(ALL s_score) 平均分 FROM score <!--ALL可省略，不统计为null的数-->
        SELECT AVG(DISTINCT s_score) 平均分 FROM score <!--重复的值只返回一个-->
        SELECT CEIL(AVG(DISTINCT s_score)) 平均分 FROM score <!--CEIL向上取整-->

        MAX/MIN：统计最大/最小值；结构：SELECT MAX/MIN(字段名) 别名 FROM 表名

        使用多个聚合函数时用逗号隔开

        聚合函数做条件时，不能写在WHERE中，只能写在HAVING子句中，having是对group by子句的结果进行条件过滤，只能放在group by子句后


        子查询：查询中包含查询，相关子查询，非相关子查询
        SELECT中嵌套子查询，返回的是单行、单列的数据，往往都是相关子查询，可能需要使用别名
        FROM中嵌套子查询：SELECT * FROM (子查询) AS 别名；此子查询返回多行多列数据
        WHERE中嵌套子查询：SELECT * FROM 表名 WHERE (子查询) [AND 条件表达式]；此子查询返回多行单列数据

        ALL 要求子查询返回的结果是单列，可为单行或多行
        ANY 要求子查询返回的结果是单列，单行或多行
        EXISTS 子查询只要返回了行，其值就为真；子查询条件为真时，则返回行
        NOT EXISTS 子查询只要没返回行，其值就为真；子查询条件为假时，不会返回行
        EXISTS，NOT EXISTS不关心返回什么值，只关心是否有内容返回，它们后面总是跟一个子查询，且往往写成相关子查询
        一般用IN，不用EXISTS；多用NOT EXISTS，少用或不用NOT IN


        表联接(其为横向联接)：SELECT 列1,列2 FROM 表1 JOIN 表2 ON 表1.列 = 表2.列 <!--用JOIN联接，ON添加联接条件，有更多表则在后面依次再加join和on-->
        表联接分类：内联接、外联接(又分左外联接、右外联接)、全联接(MySQL中不支持全联接)

        内联接：select * from 表1 inner join 表2 on 表1.字段 = 表2.字段 <!--inner可以省略，内联接是指使用比较运算符根据每个表共有的列的值匹配两个表中的行；注意它只返回条件匹配的行-->
        内联接另一种语法：select * from 表1 , 表2 where 表1.字段 = 表2.字段

        外联接：<!--outer可省略，被定义为外联接的表的数据行都要返回(不管是否匹配)，而未被定义为外联接的表只返回匹配的数据行-->
        左外联接：select * from 表1 left outer join 表2.字段 = 表2.字段
        右外联接：select * from 表1 right outer join 表2.字段 = 表2.字段

        全联接(MySQL中不支持全联接)：select * from 表1 full join 表2.字段 = 表2.字段、

        联合(其为纵向联接)：UNION
        union 在联合时会排除重复的数据，第一张表投影出的字段的数量及数据类型，决定了后面所有要联接的表的字段数量和数据类型，所以要求后面所有要联合的表投影出来的字段的数据类型必须相同或相似
        union all 在联合时不会排除重复的数据

        当投影中有相同的字段名时，必须制定每个字段来源于哪个表，若不指定则会报错

        数据库设计规范：
        第一范式：列不可再分(值必须唯一)，行不可重复(定义主键)
        第二范式：非主键列必须依赖于主键列(非主依主)
        第三范式：除了主键外，其他列都不互相依赖(非主独立)



        node.js<!--此部分笔记参看每节课的dome代码-->
        创建服务器：
        var http=require("http");<!--引入HTTP模块，并赋给一个http对象(所谓变量)-->
        http.createServer(function(request,response){ <!--HTTP对象的创建服务器的一个方法：createServer；function为一个回调函数，其中包含两个参数-->
        response.writeHead(200,{"content-type":"text/plain;charset=utf-8"}); <!--响应头部信息,200表示服务器请求成功，{键1：值2，键2：值2，...}，charset=utf-8为响应内容有文本时的编码方式(若是非文本类型文件则不设置此项),
                                                                                   content-type表示响应内容的类型，text/plain表示无样式文本,text/html为文本内容的html文件，text/css为文本内容的css文件...，这些都为文件的MIME类型-->
        response.write(); <!--响应内容-->
        response.end(); <!--响应结束-->
        }).listen(8888); <!--给服务器添加一个监听端口，调用listen()-->
        引入文件：
        var myfs=require("fs");<!--引入文件系统模块(可多文件进行读写等操作)-->
        http.createServer(function(request,response){
        <!--myfs.readFile(路径参数，编码参数，回调函数)，排错方法可用console.log(err)，console.log(data)-->
        myfs.readFile("client/index.html","utf-8",function(err,data){  <!--响应成功文件则存储在data对象内，响应失败则将错误信息存储在err对象中-->
        response.writeHead(200,{"content-type":"text/html;charset=utf-8"}); <!--因响应的是html文件而不是其中的代码，所以要用text/html-->
        response.write(data); <!--响应成功文件存于data中-->
        response.end(); <!--响应结束-->
        });
        }).listen(8888); <!--给服务器添加一个监听端口，调用listen()-->
        要使根据不同请求路径得到相应的响应则需要获取请求路径：
        var mypath=request.url; <!--获取请求路径-->
        var myArray=[];
        myArray=mypath.split(".");<!--以小数点.分割获取的请求路径，myArray[1]中则存储了引入的文件类型(后缀名),则可根据后缀名的不同设置相应的响应内容类型-->
        myfs.readFile("client"+mypath,"utf-8",function(...){...});

        把一个函数从私有函数变成公有函数的方法：
        exports.函数名=function(形参){ 函数内容}
        若要在其他js文件使用此函数，则要在要使用它的js文件中加载此函数所在的js文件：
        var myjs=require("./server/函数所在js文件");<!--nodejs的相关文件放在server中，./表示从当前文件开始找-->
        myjs.函数名(实参);

        var mypath=request.url;
        var url=require("url");
        url.parse(mypath).pathname;<!--获取url的名字部分，一般情况下与request.url结果一样，但若请求时的url中后面还有？等部分时此法可单独提取地址文件名，而request.url会将其后所有部分都返回，不利于用上面的方法获取文件后缀名-->
        与JavaScript中location对象各属性类似

        express框架：
        var express=require("./server/node_modules/express");<!--引入express框架-->
        var http=express();<!--创建服务器-->
        http.configure(function(){
        http.use(express.logger("dev"));<!--以开发模式记录服务的访问日志(自行了解其他模式)-->
        <!--中间件，要注意各中间件的顺序-->
        http.use(express.bodyParser());<!--post请求的数据处理模式-->
        http.use(express.methodOverride());<!--非post请求，转换成post请求并处理数据-->
        http.use(app.router);<!--使用服务http路由模块,抢先拦截单独的路由请求(如loginPost.do、registerGet.do等)-->
        http.use(express.static(__dirname+"/client"));<!--设置静态资源路径，注意dirname前面是两个_，__dirname是express中的全局变量，表示是项目所在根目录，及当前项目的demo目录，client前必须加"/"-->
        http.use(express.favicon(__dirname+"/client/images/图片文件"));<!--设置标签栏上的ico小图标-->
        http.use(express.errorHandler());<!--express会把错误打印到控制台-->
        });
        http.listen(8080);<!--设置端口也可用http.set("port",8080)，然后再获取端口-http.listen(http.set("port"))->

        http.get();http.post();

        MVC(Model Views Controller)
        <%=  %> <!--字符转义，不会执行js脚本-->
        <%-  %> <!--不转义，会执行js脚本-->
        <%   %> <!--会执行基本的js脚本，如循环、选择、定义变量等-->
        <%- include 模板名 %>
        <!-- 视图只能写在视图中，不能写在静态页面中-->


        HTML5：
        语义化：指有特定作用意义的标签。语义化标签如HTML4中的form，table，img，h1，p等；非语义化标签如HTML4中的div，span，它们无任何默认的CSS属性。
        HTML5：section，main，article，header，footer，nav，menu，aside，figure等

        HTML5中新增的表单控件和input属性：
        <form action="regsiter.do" id="myform">
            <!-- novalidate放在form中,表示不验证此表单中所有数据域。-->
            浏览器：<input type="text" name="brower" list="browers"/>
            <datalist id="browers">
                <option value="ie 6">ie 7</option>
                <option value="ie 7">ie 7</option>
                <option value="ie 8">ie 8</option>
                <option value="ie 9">ie 9</option>
                <option value="ie 10">ie 10</option>
            </datalist>
            <!-- datalist标签的id值，与input标签中的list值相同，这样才能让上面的input与下面的datalist相关联-->
            <!--浏览器显示时，待选列表中左边显示datalist选项option中的value值，右边会显示option标签内的值，若value值与option标签中的值相同则只显示value值(如后四项)，不同则都会显示出来(如前一项)-->
            <br/>
            name: <input type="text" required="required" novalidate />
            name: <input type="text" novalidate />
            <!-- required属性：必须填写的项 ，如果不写，则出错浏览器提示必填。novalidate,不验证此项(同一个input中不要和required一起用，有冲突，novalidate将不起作用)。-->
            <br/>
            color: <input type="color" name="color" onchange="alert(this.value)"/>
            <!-- 颜色选择，默认为黑色，this.value为当前颜色的十六进制值(有#号)，颜色改变时弹出此值-->
            <br/>
            email: <input type="email" name="email"/>
            <!--邮箱，默认要求邮箱号中间必须包含@符号，无其他要求，不满足则弹出提示，不输入不会提示-->
            <br/>
            age: <input type="number" name="age" id="age" min="1" max="120" step="1" value="44"/>
            <!-- 数字型，min和max表示数值区间，step为增减按钮按一次值变化的步长，value为开始的默认显示值-->
            <br/>
            search: <input type="search" name="search" id="search" placeholder="gxa"/>
            <br/>
            url: <input type="url" name="url" id="url" autofocus/>
            <!-- 网络联接地址，要求必须以http://或https://开头，否则会提示让输入地址-->
            <br/>
            tel: <input type="tel" pattern="(\d{3}-\d{8})|(\d{4}-\d{7})"
                        oninput="setCustomValidity('')"
                        oninvalid="setCustomValidity('请按中国固定电话格式输入');"/>
            <!--
             pattern，设置规则；oninvalid，验证事件。
             oninvalid,当第一次输入后验证失败，则会影响后面的正确输入的结果。仍然报错。
             必须加oninput事件，把自定义出错提示清空，才能正确提交数据。
             setCustomValidity('提示内容')，自定义报错提示内容
            -->
            <br/>
            range滑条： <input type="range" name="range" id="range" step="1" min=1 max="100" value="1"/>
            <br/>
            datetime: <input type="datetime" name="dt1"/>
            <br/>
            date: <input type="date"/>
            <!-- 年月日，可选择设置-->
            <br/>
            time: <input type="time" name="time" id="time"/>
            <!-- 时间：时：分，可选择设置-->
            <br/>
            datetime-local:<input type="datetime-local" name="localtime" id="localtime"/>
            <!-- 年月日时分，可选择设置-->
            <br/>
            week:<input type="week" name="week" id="week"/>
            <!-- xx年第x周，可选择设置-->
            <br/>
            month:<input type="month" name="month" id="month"/>
            <!-- xx年x月，可选择设置-->
            <br/>
            （多）文件上传：<input type="file" name="file" id="file"/>
            <!--  设置multiple="multiple" 允许多个文件上传-->
            <br/>
            用图片来提交表单：<input type="image" src="images1/uno_19.png" alt="" width="20" height="10"/>
            <br/>
            <input type="submit"/>
            <button type="button">提交</button>
            <!--
            button元素的type属性的默认值：submit
              reset, button
            -->
            <progress value="34" max="100">
                <!--这是一个进度条 -->
            </progress>
            <br/>
            加密: <keygen name="security" />
        </form>
        <input type="text" name="xxx"  form="myform" value="xxxxxx"/>
        <!--在form标签以外的表单元素，可以通过form属性的值，与form标签中的id属性相关连，这样在提交表单时，就可以一起提交数据了。-->


        canvas绘图：
        <!--<body>-->
        <!--canvas,可减少flash、图片的应用-->
        <canvas id="myCanvas" width="1000" height="400"></canvas><!--canvas的宽高只能在行间设置，用CSS控制会出问题，其他属性可以CSS设置-->
        <script type="text/javascript">
            //绘制矩形
            //1. 拿到canvas对象；
            var canvas = document.getElementById("myCanvas");
            //2. 获取上下文环境,(画布）
            var ctx = canvas.getContext("2d");
            //3. 设置填充 或 绘制的样式；
            ctx.strokeStyle="yellow";//设置边框颜色(绘制样式)，fillStyle为填充样式
            ctx.lineWidth="5";//设置边框线宽(不加单位)
            //4. 定义一个矩形；
            ctx.rect(0,0,400,200);//（x,y,w,h）
            //5. 填充 或 绘制。
            ctx.stroke();//此方法对应strokeStyle，表应用绘制边线这个方法；fill()是对应fillStyle的方法(填充内部)

            ctx.fillStyle="red";//第3步, 如果没有设置样式，则颜色默认是黑的。
            //合并第4、5步
            ctx.fillRect(100,100,200,200);//（x,y,w,h），用红色填充画一个从坐标(100,100)开始的宽400，高200的矩形；
            //strokeRect为绘制矩形框

            //画直线
            //1.  开始一个路径；
            ctx.beginPath();
            //2. 设置样式，线条粗细等
            ctx.strokeStyle="pink";
            ctx.lineWidth=50;
            //直线的两端，圆角的效果。不能与closePath()同时用，效果将失效。
            ctx.lineCap="round";
            //3. 移动到一个开始坐标点
            ctx.moveTo(500,0);//起点坐标，相当于是把画笔移动到一个坐标点。
            //4. 依次连接到下一个坐标点，两点间会产生一条直线。
            ctx.lineTo(500,200);
            ctx.lineTo(700,200);
            //    ctx.lineTo(500,0)；//与起点重合，表示闭合整个曲线段，即闭合路径
            //5. 闭合路径
            //    ctx.closePath();//将终点与起点自动连接，形成闭合曲线，只绘制一条曲线不用闭合
            //6. 绘制直线
            ctx.stroke();//绘制边线方法
            //清除画布
            ctx.clearRect(0,0,1000,400);//（x,y,w,h），清除画布指定区域内容

            //画圣诞树
            ctx.beginPath();
            ctx.fillStyle="green";
            ctx.moveTo(200,0);
            ctx.lineTo(150,50);
            ctx.lineTo(250,50);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle="yellowgreen";
            ctx.moveTo(200,40);
            ctx.lineTo(120,100);
            ctx.lineTo(280,100);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle="yellowgreen";
            ctx.moveTo(200,90);
            ctx.lineTo(100,150);
            ctx.lineTo(300,150);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle="red";
            ctx.fillRect(190,150,20,100);

            //画圆
            ctx.beginPath();
            ctx.strokeStyle="red";
            ctx.lineWidth=4;
            //第1、2个参数，表示圆心坐标；第三个参数，表示 半径。第4，5个参数，分别表示开始角度和结束的角度。
            //0度，在时钟的三点方向，即直角坐标系中的X轴正方向
            //角度：Math.PI/180*N
            //第6个参数，表示绘制方向，false 按顺时针（默认值），true 为逆时针，可参考直角坐标系中角度定义true对应正角度(逆时针)，false对应负角度(顺时针)；
            ctx.arc(300,150,50,Math.PI/180*0,Math.PI/180*180,true);//arc表定义一个圆
            //如果闭合了路径，则是一种不完全的圆。
            //    ctx.closePath();
            ctx.stroke();

            //画各种不同角度的图形
            ctx.beginPath();
            //    ctx.arc(400,200,50,Math.PI/180*90,Math.PI/180*45,true);
            ctx.arc(400,200,50,Math.PI/180*90,Math.PI/180*45,false)
            //通过以上两个图形的比较，我们发现角度位置不受顺时针或逆时针这个参数的影响；
            //顺时针或逆时针时，画笔经过的路径不一样，所以画出来的图形就不一样。
            ctx.stroke();
            //如果闭合一个路径。
            ctx.beginPath();
            ctx.strokeStyle="blue";
            ctx.arc(500,200,50,Math.PI/180*70,Math.PI/180*145,false)
            ctx.closePath();
            ctx.stroke();
            //实心圆
            ctx.beginPath();
            ctx.fillStyle="blue";
            ctx.arc(600,300,50,Math.PI/180*0,Math.PI/180*260,false)
            ctx.closePath();
            ctx.fill();

            //绘制变形图形
            ctx.translate(x,y);//移动坐标轴原点
            ctx.scale(x,y);//放缩
            ctx.rotate(angle);//angle指旋转角度(幅度角度)，负值表逆时针旋转

            <!-- canvas绘制手表步骤见HTML5-day2-demo -->

            <!-- canvas绘制图像步骤见HTML5-day3-demo -->
        </script>
        <!--</body>-->

        HTML5中web Storage下方法：
        1、localStorage对象本身带有方法有：(sessionStorage也有)
        　　添加键值对：localStorage.setItem(key,value)
        　　获取键值：localStorage.getItem(key)
        　　删除键值对：localStorage.removeItem(key)
        　　清除所有键值对：localStorage.clear()
        　　获取localStorage的属性名称（键名称）：localStorage.key(index)  <!--其中index是各键值对对应的下标-->
        还有一个和普通对象不一样的属性length：获取localStorage中保存的键值对的数量：localStorage.length。
        localStorage也可用一般对象添加改变键值对的方法，即localStorage.key=value;
        在iPhone/iPad上有时调用setItem()时会出现诡异的QUOTA_EXCEEDED_ERR错误。解决方法是在setItem之前先removeItem()。
        所以从这个兼容问题来看，貌似使用对象添加/删除键值对更方便一些，兼容也更强一些。

        须注意：写代码时给localStorage、sessionStorage保存数据可使用不同数据类型进行赋值，但它们在实际保存数据时都是以字符串的形式保存的，所以在取出使用时应再转换成要应用的数据类型；

    </div>

    <!--*********************************************************************************************************-->
    <!--********************************************* 第四部分start *********************************************-->
    <!--*********************************************************************************************************-->
    <pre>
    <head>
        <meta charset="UTF-8">
        <!-- 移动端开发:必需的一条meta标签-->
        <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"> <!--最后user-scalable=no表示用户不可缩放，若不写则表示用户可缩放-->
        <title>阶段四笔记</title>
        <style type="text/css">
            /*CSS属性hack：渐进识别的方式，从总体中逐渐排除局部，可查看相关技术博客文章有详尽讲解*/
            /*首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。*/
            /*接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。*/
            .box{
                background-color: yellow;/*所有识别*/
                background-color: red\9;/*”\9“是IE6、7、8、9、10识别；“\0″对IE8/IE9/IE10都生效；“\9\0″只对IE9/IE10生效*/
                +background-color: green;/*IE6、7识别*/
                _background-color: blue;/*IE6识别*/
                width: 200px;height: 200px;
            }
        </style>
    </head>
    </pre>
    <script type="text/javascript" charset="UTF-8">

        //JS面向对象:

        function Cat(形参){ 定义对象的相关属性和方法 }
        cat1=new Cat(实参);

        console.log(cat1 instanceof Cat);      //instanceof，返回true或false；此处即表示检查cat1是否是Cat对象的实例

        console.log(cat1.constructor);         //constructor，查询构造者是谁；此处即表示car1这个实例的构造者是谁(即Cat这个对象)

        Cat.prototype.eat=function(){           //prototype，扩展对象的属性或方法，扩展的属性或方法本身并不在原对象中，只有new出的对象引用它们时才出现在此对象中，以减少内存的占用，Object是最上层对象
            console.log("吃老鼠");};
        Object.prototype.abc="测试";

        console.log("abc" in cat1);             //in 运算符：可以检查该对象是否能够使用这个属性或方法，返回true或false,但是不会告诉这个方法是本身所拥有还是原型链上找到的

        console.log(cat1.hasOwnProperty("abc")); //hasOwnProperty:检查是否本身拥有这个属性或方法

        //注意数据存储的堆栈关系

        //对象属性和方法的继承:
        function Plane(){//公用飞机模板
            this.x=100;
            this.y=200;
            this.speed=10;
            this.move=function(){
                console.log("飞机移动");
            }
        }
        function playPlane(){//玩家飞机模板
    //        this.x=100;
    //        this.y=200;
    //        this.speed=10;
    //        this.move=function(){
    //            console.log("飞机移动");
    //        };
            Plane.call(this);//继承，让玩家飞机拥有Plane的特性，也就是上面注释掉的部分
            this.attack=function(){ //添加自身另外的属性或方法
                console.log("玩家飞机攻击");
            };
            this.x=1000;//放在继承之后可覆盖继承的同一个属性或方法
        }

        //call和apply都是继承，apply(obj,args)  apply:申请 请求 适用
        function Person(name,age){
            this.name=name;
            this.age=age;
        }
        function student(grade,age,name){
            Person.apply(this,arguments);//将Person应用于this(即student)，实参按顺序以类似数组形式存储在arguments中
            /*apply有两个参数：
             * 1.this代表的是student这个学生模板
             * 2.arguments,当前函数的一个内置属性，非常类似Array，储存的是函数中的实参(顺序按实参顺序)*/
            this.grade=grade;
    //        alert(arguments[0]);
    //        alert(arguments[1]);
    //        alert(arguments[2]);
    //        alert(arguments.length);
        }
        //形参对应实参顺序先按继承的形参顺序对应，再按此对象另外的形参所在位置对应
        var student1=new student("5岁","赵四","幼儿园大班");
        console.log("姓名"+student1.name);//5岁
        console.log("年龄"+student1.age);//赵四
        console.log("年级"+student1.grade);//5岁

        /*call和apply区别：
         * apply：中形参的位置调换不会影响最后结果，只有调换实参的位置才会影响结果
         * call形参或者实参的位置调换都会影响到结果*/

        //继承的第三种方法
        function Plane(a,b){//公用飞机模板
            this.x=a;
            this.y=b;
            this.move=function(){
                console.log("飞机移动");
            }
        }
        function newPlane(){
            //创建后无任何属性
        }
        //    var a=new Plane(66,77);//通过prototype拓展newPlane模板
        newPlane.prototype=new Plane(66,77);//通过prototype拓展newPlane模板

        var np=new newPlane();
        console.log("prototype方式继承的"+np.x);//66

        function girl(name,shenGao){//公用模板
            this.name="张三";
            this.shenGao=shenGao;
        }
        function myGirl(name,shenGao){
            girl.call(this,name);
        }
        var myGirl1=new myGirl("孙五","155cm");
        alert("姓名："+myGirl1.name);//张三，因myGirl继承girl，而girl中的name属性值已被固定


        //闭包:
        //函数内部没有var声明的变量会被当作全局变量，但并不能直接调用它，只有其所在函数被执行了一次后它才能被全局调用，否则是is not defined；
        //setTimeout和setInterval是window对象下的方法
        //"use strict" 指严格模式下运行



    </script>

<script type="text/javascript" charset="UTF-8">

</script>
</body>
</html>