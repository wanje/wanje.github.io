<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>设计模式</title>
    <style>
        .code {display: block;white-space: pre;font-family: monospace;}
    </style>
</head>
<body>
<pre>

    设计模式原则：
    1、开闭原则：对扩展开放，对修改关闭；
    2、里式转换原则：子类继承父类，单独调完全可运行；
    3、依赖倒转原则：引用一个对象，如果这个对象有底层类型，直接引用底层；
    4、接口隔离原则：每个接口应该只有一种角色；
    5、合成/聚合复用原则：x新的对象应使用一些已有的对象，使之成为新对象的一部分；
    6、迪米特原则：一个对象应对其他对象有尽可能少的了解


    //=========== 单例模式 ===========
    解释：
    单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，若存在直接返回，若不存在就创建了再返回，这就确保了一个类只有一个实例对象。
    在JavaScript中，单例作为一个命名空间提供者，从全局命名空间中提供一个唯一的访问点来访问该对象。

    作用：
    1、模块间通信；
    2、系统中某个类的对象只能存在一个；
    3、保护自己的属性和方法；

    注意事项：
    1、注意this的使用；
    2、闭包容易造成内存泄漏，不需要的赶快清理掉；
    3、注意new的成本。（继承）


    //=========== 构造函数模式 ===========
    解释：
    构造函数用于创建特定类型的对象——不仅声明了使用的对象，还可以接受参数以便第一次创建对象的时候设置对象的成员值。
    可以自定义z自己的构造函数，然后在里面声明自定义类型对象的属性和方法。
    在JavaScript中，构造函数通常认为是用来实现实例的，因为JavaScript中没有类的概念。通过 new 关键字来调用自定义的构造函数，在构造函数内部，this 关键字指向新创建的对象。

    作用：
    1、用于创建特定类型的对象；
    2、第一次声明的时候给对象赋值；
    3、自己声明构造函数，赋予属性和方法；

    注意事项：
    1、声明函数的时候处理业务逻辑；
    2、区分与单例的区别，配合单例实现初始化；
    3、构造函数命名采用大驼峰形式；（建议）
    4、注意new的成本。（继承）


    //=========== 建造者模式 ===========
    解释：
    建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
    其主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。

    作用：
    1、分步创建一个复杂的对象；
    2、解耦封装过程和具体创建的组件；
    3、无需关心组件如何组装；

    注意事项：
    1、一定要有个稳定的算法进行支撑；
    2、加工工艺是暴露的。


    //=========== 工厂模式 ===========
    解释：
    工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型(抽象工厂)。
    该模式在创建对象的流程赋值的时候很有用，比如依赖于很多设置文件。

    作用/适用情况：
    1、对象的构建十分复杂；
    2、需要依赖具体的环境创建不同实例；
    3、处理大量具有相同属性的小对象；

    注意事项：
    1、不能滥用工厂模式，有时候可能反倒只会给代码增加复杂度。



</pre>
</body>
</html>