<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lit 框架创建 Web Components | Notebook</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/docs/favicon.ico">
    <meta name="description" content="个人学习记录，资料收集备忘">
    
    <link rel="preload" href="/docs/assets/css/0.styles.afbc35f2.css" as="style"><link rel="preload" href="/docs/assets/js/app.148f908e.js" as="script"><link rel="preload" href="/docs/assets/js/2.23b2ce06.js" as="script"><link rel="preload" href="/docs/assets/js/14.c0bae6d1.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.ebea01df.js"><link rel="prefetch" href="/docs/assets/js/11.bcfa9455.js"><link rel="prefetch" href="/docs/assets/js/12.82a66467.js"><link rel="prefetch" href="/docs/assets/js/13.1ebc2477.js"><link rel="prefetch" href="/docs/assets/js/15.09cd86df.js"><link rel="prefetch" href="/docs/assets/js/16.d78aab94.js"><link rel="prefetch" href="/docs/assets/js/17.3f435466.js"><link rel="prefetch" href="/docs/assets/js/18.594e5226.js"><link rel="prefetch" href="/docs/assets/js/19.c9501643.js"><link rel="prefetch" href="/docs/assets/js/20.4678f3ca.js"><link rel="prefetch" href="/docs/assets/js/21.97d2fab5.js"><link rel="prefetch" href="/docs/assets/js/22.caa3075a.js"><link rel="prefetch" href="/docs/assets/js/23.2b5df3dc.js"><link rel="prefetch" href="/docs/assets/js/24.9100df29.js"><link rel="prefetch" href="/docs/assets/js/25.a04e4447.js"><link rel="prefetch" href="/docs/assets/js/26.5b3451c4.js"><link rel="prefetch" href="/docs/assets/js/27.872e335c.js"><link rel="prefetch" href="/docs/assets/js/28.3b7abfca.js"><link rel="prefetch" href="/docs/assets/js/29.15acbc94.js"><link rel="prefetch" href="/docs/assets/js/3.1998dc2b.js"><link rel="prefetch" href="/docs/assets/js/30.fb5d163b.js"><link rel="prefetch" href="/docs/assets/js/31.8d7cef9c.js"><link rel="prefetch" href="/docs/assets/js/32.4694d926.js"><link rel="prefetch" href="/docs/assets/js/33.0629d0a7.js"><link rel="prefetch" href="/docs/assets/js/34.ca1cb712.js"><link rel="prefetch" href="/docs/assets/js/35.fd70df01.js"><link rel="prefetch" href="/docs/assets/js/36.8943ab55.js"><link rel="prefetch" href="/docs/assets/js/37.c38abfcd.js"><link rel="prefetch" href="/docs/assets/js/38.2e9153f6.js"><link rel="prefetch" href="/docs/assets/js/39.94ac212c.js"><link rel="prefetch" href="/docs/assets/js/4.774040a3.js"><link rel="prefetch" href="/docs/assets/js/40.5f52d4d9.js"><link rel="prefetch" href="/docs/assets/js/41.06fb0f42.js"><link rel="prefetch" href="/docs/assets/js/42.50a95451.js"><link rel="prefetch" href="/docs/assets/js/43.d3df4473.js"><link rel="prefetch" href="/docs/assets/js/44.7dc4d101.js"><link rel="prefetch" href="/docs/assets/js/45.84f2778f.js"><link rel="prefetch" href="/docs/assets/js/46.e2e3246c.js"><link rel="prefetch" href="/docs/assets/js/47.948ed66e.js"><link rel="prefetch" href="/docs/assets/js/48.8cf6d383.js"><link rel="prefetch" href="/docs/assets/js/49.6440315e.js"><link rel="prefetch" href="/docs/assets/js/5.e5b00e90.js"><link rel="prefetch" href="/docs/assets/js/50.e33a48ac.js"><link rel="prefetch" href="/docs/assets/js/51.aaecbdaa.js"><link rel="prefetch" href="/docs/assets/js/52.cdf47fbc.js"><link rel="prefetch" href="/docs/assets/js/53.c2fb1c04.js"><link rel="prefetch" href="/docs/assets/js/54.b57e310b.js"><link rel="prefetch" href="/docs/assets/js/55.af5903a0.js"><link rel="prefetch" href="/docs/assets/js/56.fda0608f.js"><link rel="prefetch" href="/docs/assets/js/57.5612d7e1.js"><link rel="prefetch" href="/docs/assets/js/58.4fa6dfc7.js"><link rel="prefetch" href="/docs/assets/js/59.a5bbbaa8.js"><link rel="prefetch" href="/docs/assets/js/6.a02e3f41.js"><link rel="prefetch" href="/docs/assets/js/60.5d3d9a29.js"><link rel="prefetch" href="/docs/assets/js/61.a4988bba.js"><link rel="prefetch" href="/docs/assets/js/62.beb94abf.js"><link rel="prefetch" href="/docs/assets/js/63.cec4b0ff.js"><link rel="prefetch" href="/docs/assets/js/64.9c15a355.js"><link rel="prefetch" href="/docs/assets/js/65.93ac231d.js"><link rel="prefetch" href="/docs/assets/js/66.0d331a27.js"><link rel="prefetch" href="/docs/assets/js/67.fe174724.js"><link rel="prefetch" href="/docs/assets/js/68.1c70f1f3.js"><link rel="prefetch" href="/docs/assets/js/69.65bc94c4.js"><link rel="prefetch" href="/docs/assets/js/7.d1d65966.js"><link rel="prefetch" href="/docs/assets/js/70.110662a3.js"><link rel="prefetch" href="/docs/assets/js/71.e5e2ca7e.js"><link rel="prefetch" href="/docs/assets/js/72.c3f84b73.js"><link rel="prefetch" href="/docs/assets/js/73.96be54ce.js"><link rel="prefetch" href="/docs/assets/js/74.f859356c.js"><link rel="prefetch" href="/docs/assets/js/75.96472c9d.js"><link rel="prefetch" href="/docs/assets/js/76.c8662743.js"><link rel="prefetch" href="/docs/assets/js/77.53deafab.js"><link rel="prefetch" href="/docs/assets/js/78.25d8ca21.js"><link rel="prefetch" href="/docs/assets/js/79.a1b8604c.js"><link rel="prefetch" href="/docs/assets/js/8.87c3968f.js"><link rel="prefetch" href="/docs/assets/js/80.24ad8142.js"><link rel="prefetch" href="/docs/assets/js/81.72d0797f.js"><link rel="prefetch" href="/docs/assets/js/9.e0d2f965.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.afbc35f2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/logo.png" alt="Notebook" class="logo"> <span class="site-name can-hide">Notebook</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记分类" class="dropdown-title"><span class="title">笔记分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记分类" class="mobile-dropdown-title"><span class="title">笔记分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/docs/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="https://wanje.github.io/demo_notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记分类" class="dropdown-title"><span class="title">笔记分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记分类" class="mobile-dropdown-title"><span class="title">笔记分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/docs/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="https://wanje.github.io/demo_notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/html/HTML零散集.html" class="sidebar-link">HTML零散集</a></li><li><a href="/docs/html/a标签的各种用途.html" class="sidebar-link">a标签的各种用途</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/js/JS错题本.html" class="sidebar-link">JS错题本</a></li><li><a href="/docs/js/JS零散集.html" class="sidebar-link">JS零散集</a></li><li><a href="/docs/js/数组Array.html" class="sidebar-link">数组Array</a></li><li><a href="/docs/js/字符串String.html" class="sidebar-link">字符串String</a></li><li><a href="/docs/js/计算Math.html" class="sidebar-link">计算Math</a></li><li><a href="/docs/js/事件Event.html" class="sidebar-link">事件Event</a></li><li><a href="/docs/js/WebComponents.html" class="sidebar-link">Web Components</a></li><li><a href="/docs/js/Lit创建WebComponents.html" class="active sidebar-link">Lit 框架创建 Web Components</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#定义元素" class="sidebar-link">定义元素</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#渲染内容" class="sidebar-link">渲染内容</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#响应式属性" class="sidebar-link">响应式属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#变更对象和数组属性" class="sidebar-link">变更对象和数组属性</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#属性数据转换" class="sidebar-link">属性数据转换</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#attribute反射-双向绑定" class="sidebar-link">attribute反射(双向绑定)</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义property访问器" class="sidebar-link">自定义property访问器</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义属性变更检测" class="sidebar-link">自定义属性变更检测</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#css-样式" class="sidebar-link">CSS 样式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#从父类继承样式" class="sidebar-link">从父类继承样式</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#共享样式" class="sidebar-link">共享样式</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#动态样式class和style" class="sidebar-link">动态样式class和style</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#主题样式风格" class="sidebar-link">主题样式风格</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#组件生命周期" class="sidebar-link">组件生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#标准自定义元素生命周期" class="sidebar-link">标准自定义元素生命周期</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#响应式更新生命周期" class="sidebar-link">响应式更新生命周期</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#外部生命周期钩子" class="sidebar-link">外部生命周期钩子</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#shadow-dom" class="sidebar-link">Shadow DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#插槽" class="sidebar-link">插槽</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义渲染根节点-shadowroot" class="sidebar-link">自定义渲染根节点 shadowRoot</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#事件" class="sidebar-link">事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义事件监听器选项" class="sidebar-link">自定义事件监听器选项</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#向元素本身或showroot添加事件监听器" class="sidebar-link">向元素本身或showRoot添加事件监听器</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#给-shadow-dom-之外内容添加事件" class="sidebar-link">给 shadow DOM 之外内容添加事件</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#派发自定义事件" class="sidebar-link">派发自定义事件</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#事件派发时机" class="sidebar-link">事件派发时机</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#事件派发器与监听器间的通信" class="sidebar-link">事件派发器与监听器间的通信</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#综合示例" class="sidebar-link">综合示例</a></li></ul></li></ul></li><li><a href="/docs/js/File文件API.html" class="sidebar-link">File文件API</a></li><li><a href="/docs/js/鼠标拖放与拖拽dnd.html" class="sidebar-link">鼠标拖拽与拖放</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>ES6+</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/js/es6+/Class.html" class="sidebar-link">Class</a></li><li><a href="/docs/js/es6+/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/docs/js/es6+/async-await.html" class="sidebar-link">async/await</a></li><li><a href="/docs/js/es6+/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/docs/js/es6+/Reflect.html" class="sidebar-link">Reflect</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS零散集.html" class="sidebar-link">CSS零散集</a></li><li><a href="/docs/css/scss语法.html" class="sidebar-link">SCSS基础语法</a></li><li><a href="/docs/css/CSS选择器世界.html" class="sidebar-link">CSS选择器世界</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>CSS世界</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS世界/层叠规则.html" class="sidebar-link">层叠规则</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>CSS新世界</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS新世界/第6章.html" class="sidebar-link">第 6 章 全新的布局方式</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>绘图&amp;动画</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/draw-animation/D3js.html" class="sidebar-link">D3.js</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Threejs开发指南</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/vue/vue工程配置.html" class="sidebar-link">Vue工程创建及配置</a></li><li><a href="/docs/vue/vue基础语法.html" class="sidebar-link">Vue基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/react/react工程配置.html" class="sidebar-link">React工程创建及配置</a></li><li><a href="/docs/react/react基础语法.html" class="sidebar-link">React基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/typescript/类型/为什么需要类型.html" class="sidebar-link">为什么需要类型</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>泛型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>类型转换</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/docs/typescript/模块/CommonJS兼容模块.html" class="sidebar-link">CommonJS兼容模块</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>命名空间</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>理解声明</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/node/Node模块机制.html" class="sidebar-link">Node模块机制与NPM包</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/webpack/webpack4.x笔记.html" class="sidebar-link">webpack4.x笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Python</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/python/python基础语法.html" class="sidebar-link">Python基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/others/参考内容.html" class="sidebar-link">参考内容</a></li><li><a href="/docs/others/lint-format.html" class="sidebar-link">代码检查与格式化</a></li><li><a href="/docs/others/Markdown语法.html" class="sidebar-link">Markdown语法</a></li><li><a href="/docs/others/Git使用.html" class="sidebar-link">Git使用</a></li><li><a href="/docs/others/Gulp使用.html" class="sidebar-link">Gulp使用</a></li><li><a href="/docs/others/Rollup使用.html" class="sidebar-link">Rollup使用</a></li><li><a href="/docs/others/Nginx配置.html" class="sidebar-link">Nginx基础配置与操作</a></li><li><a href="/docs/others/环境&amp;软件安装.html" class="sidebar-link">环境&amp;软件安装</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lit-框架创建-web-components"><a href="#lit-框架创建-web-components" class="header-anchor">#</a> Lit 框架创建 Web Components</h1> <p>Lit 是一个 Web 工具库，它提供了一种简单的方式来创建可重用的 Web Components 标准组件或叫<strong>自定义元素</strong>。</p> <p>当前笔记都基于 Lit3，其不再支持 IE11，若要兼容 IE11 可使用 Lit2.x，Lit2 到 Lit3 几乎没有重大变更，具体可参考 <a href="https://lit.dev/docs/releases/upgrade/" target="_blank" rel="noopener noreferrer">Lit3 升级指南<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>该框架包含多个常用类和工具函数（TS下还有一些简写的装饰器语法）：</p> <ul><li><code>LitElement</code>：一个基类，用于创建自定义 Web Components，其是<code>ReactiveElement</code>(实现了响应式属性)的子类，而<code>ReactiveElement</code>又是原生<code>HTMLElement</code>的子类</li> <li><code>html</code>：一个模板字符串标签函数，用于在组件中创建 HTML 模板</li> <li><code>css</code>：一个模板字符串标签函数，用于在组件中创建 CSS 样式</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <ul><li>对于 DOM 对象上的 prop 我们称为属性；</li> <li>对于元素 tag 标签上的 attr 我们称为特性。</li></ul> <p>也即是 jQuery 对象中 <code>prop()</code> 与 <code>attr()</code> 方法的区别。</p></div> <h2 id="定义元素"><a href="#定义元素" class="header-anchor">#</a> 定义元素</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 组件内容 */</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义元素（此为原生API）</span>
customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">,</span> MyElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="渲染内容"><a href="#渲染内容" class="header-anchor">#</a> 渲染内容</h2> <p>为 Lit 组件定义一个<code>render()</code>方法，该方法返回一个 HTML 模板，该模板将被插入到组件的 shadow DOM 中，大多情况下我们使用标签函数<code>html</code>处理该模板，<code>html</code>模板内也可以嵌套其他<code>html</code>子模板或模板列表（数组，略微类似 jsx 语法）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> header <span class="token operator">=</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;h1&gt;这是页头&lt;/h1&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> footer <span class="token operator">=</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;footer&gt;这是页脚&lt;/footer&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

    <span class="token comment">// 字符串模板中可以正常插入JS表达式，注意是表达式，不是代码块，也不是只能简单的属性或方法</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;section&gt;
      </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>header<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
      &lt;main&gt;
        &lt;slot&gt;
          这里是主体插槽默认内容
          &lt;ul&gt;
            </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;li&gt;item</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>item<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/li&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
          &lt;/ul&gt;
        &lt;/slot&gt;
      &lt;/main&gt;
      </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>footer<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
    &lt;/section&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">,</span> MyElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="响应式属性"><a href="#响应式属性" class="header-anchor">#</a> 响应式属性</h2> <p>Lit 中的响应式属性是通过声明静态属性<code>properties</code>对象实现的，它允许我们定义一个属性，当属性值发生变化时，Lit 会自动重新渲染组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过静态属性来定义，静态属性只能在类对象上访问(MyElement.xxx)，而不是实例对象上访问</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每个属性都包含一些可配置项，若不配置则应保留空配置对象(表示都使用默认值)</span>
    <span class="token comment">//! 此为公共响应式属性，原则上应该响应用户的输入而变化，组件内不应更改</span>
    name<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> String <span class="token punctuation">}</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number <span class="token punctuation">}</span><span class="token punctuation">,</span>
    sex<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">//! state 设为 true 表示是内部响应式状态属性，建议以下划线`_`开头以区别于公共属性，用于组件内使用</span>
    _counter<span class="token operator">:</span> <span class="token punctuation">{</span> state<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在构造函数中初始化相关属性值，注意这里不是通过 this.properties 访问</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//! 不应该使用类字段语法方式声明属性，因为该方式声明的属性不是响应式的，除非本意就是不参与响应式变化</span>
  <span class="token comment">// foo = 'default';</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每个属性都包含一些可配置项，<strong>若不配置则应保留空配置对象</strong>(表示都使用默认值)，配置项包含：</p> <ul><li><code>attribute</code>: 布尔值或字符串，默认 true，表示是否将属性映射到元素标签的 attr 上（即通过 attr 来传值），若为false，则不会进行映射关联，同时会忽略<code>converter</code>、<code>reflect</code>和<code>type</code>选项，若为字符串则表示显式指定的 attr 名字（否则默认为该 prop 的全小写形式）；</li> <li><code>converter</code>: 对象或函数，默认内置转换器，用于 DOM 的 prop 与标签的 attr 间关系转换；</li> <li><code>hasChanged</code>: 函数，每当设置属性时调用，用于判断属性值是否发生变化，不指定则默认采用严格不等式进行比较(即<code>!==</code>)；</li> <li><code>noAccessor</code>: 布尔值，默认 false，表示是否禁用属性的访问器，若为 true，则属性将不会有 getter 和 setter，且无法在组件中直接访问；</li> <li><code>reflect</code>: 布尔值，默认 false，表示是否将 prop 属性值的变更同步映射到元素标签的 attr 上，可用于数据的双向绑定；</li> <li><code>state</code>: 布尔值，默认 false，表示是否将属性标记为内部状态属性，若为 true，则不会为该属性生成元素标签对应的 attribute，且不会触发属性变化事件，此时唯一可指定的额外选项只有<code>hasChange</code>，但响应式还是具备的；</li> <li><code>type</code>: 将字符串类型的 attr 特性转换为 prop 属性时应该转换为的数据类型，如果设置了<code>converter</code>选项，则会将该字段的值传给该转换器（意味着我们可以自定义一些<code>type</code>类型），若未指定<code>type</code>则默认转换器会将其视为 String 类型；</li> <li><code>useDefault</code>: 布尔值，默认 false，表示是否使用默认值，设置为 true 可在<code>reflect</code>设置为 true 时防止初始 attr 值映射到 prop 上，并在移除相应 attr 时将 prop 重置为构造函数声明时的默认值，但若非原始 Object/Array 属性，最好避免设置为 true，因为可能已不是真正的原始默认值；</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>默认情况下，Lit 将 prop 映射为元素标签的 attr 时，其映射的 attr 名为 prop 的全小写形式，即<code>myName</code>property 会被映射为的 attr 为<code>myname</code>。</p> <p>若想自定义对应的 attr 名字，可将上面的<code>attribute</code>配置项指定为字符串即为定义的的特性名，比如多个词的属性时我们想使用更符合标签特性命名规范的烤串格式，可将前面的属性配置为<code>{ attribute: 'my-name' }</code>，此时<code>myName</code>property就将映射为<code>my-name</code>attribute。</p></div> <p>property更改可能会触发响应式更新周期，从而导致组件重新渲染其模板，其触发顺序是：</p> <ol><li>该属性的 setter 函数调用；</li> <li>setter 函数调用组件的<code>requestUpdate()</code>方法；</li> <li>属性的新旧值比较；
<ul><li>默认情况下，Lit 使用严格不等式<code>!==</code>来比较属性值是否发生变化；</li> <li>若该属性指定了<code>hasChanged</code>函数，则会将属性的旧值和新值作为参数传递给该函数以应用自定义单的比较逻辑，该函数应该返回一个布尔值，表示属性值是否发生变化；</li></ul></li> <li>若属性值发生变化，将异步安排更新，若已安排了更新，则仅执行最后一次更新；</li> <li>调用组件的<code>update()</code>方法，将更改后的属性映射到 attr 中，并重新渲染组件 HTML 模板；</li></ol> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <ol><li>上面配置项中<code>attribute</code>字段虽然会在 HTML 标签上创建对应的 attribute 以用于传值(并不代表 HTML 标签上一定会初始化存在该 attr，只是说此时就可以通过 attr 传值了)，但此时数据流是单向的，类似 Vue 中的<code>props</code>数据，但不同的是 Lit 中这些 prop 是可以更改，且更改后会反应到UI模板上，而不只是从 attr 上同步过来，若要体现该<code>attribute</code>的双向数据流绑定，则需要启用<code>reflect</code>选项，此时 prop 的变更才会同步到 attr 上；
<ul><li>需要注意的是这些配置都是符合HTML元素的标准表现的，而不是主流的 Vue/React 等组件的表现，HTML 元素中 attr 的变化基本都会同步到 DOM 的 prop 上，而 prop 也可以单独修改，但 prop 的修改并不一定都会同步到元素的 attr 上。比如元素的<code>id</code>，HTML 的 attr 和 DOM 的 prop 更改都会互相同步，而 input 元素的<code>value</code>就不一样了，attr 的变化会反应到 prop 上，但 prop 的变化并不会反应到 attr 上。</li></ul></li> <li>若改变的是一个对象或数组等引用类型的值，则不会触发更新，除非直接替换整个对象或数组，原因同 Vue2 中的响应式原理（只不过 Vue2 改写了数组的部分方法使得其可触发响应）。</li></ol> <p>对于这类数据先引起组件模板更新可借鉴下面的处理方案。</p></div> <h3 id="变更对象和数组属性"><a href="#变更对象和数组属性" class="header-anchor">#</a> 变更对象和数组属性</h3> <p>要使这类值的属性响应式更新，可采用以下方案之一：</p> <ul><li><strong>不可变数据模式</strong>：将这类数据视为不可变的，不能修改，只能产生新的，即利用旧数据生成一个新的数据来替换原来的数据，简单的数据可使用原生API解构扩展及遍历等方式生成新值，对于复杂数据结构可以使用想 <a href="https://immerjs.github.io/immer/zh-CN/" target="_blank" rel="noopener noreferrer">Immer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的工具库来处理。</li> <li><strong>手动触发更新</strong>：直接在原数据上进行更改操作，然后调用<code>requestUpdate()</code>方法手动触发更新，当不带参数调用该方法时，该方法会安排一次更新，但不会调用<code>hasChanged</code>来判断是否值发生了变化，而是强制更新，例如：<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 响应式属性</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Object <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">updateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接修改原数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
    <span class="token comment">// 手动触发更新</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requestUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;p&gt;Name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;
      &lt;p&gt;Age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;
      &lt;button @click=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>updateData<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;&gt;Update Age&lt;/button&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>但需要注意，<code>requestUpdate()</code>只会导致当前组件更新，如果组件内有将上面的<code>data</code>传给其子组件，对子组件来说数据仍是未变化的(引用未变)，也就不会触发子组件的模板更新，要触发更新就需要每个用到该<code>data</code>数据的组件都调用<code>requestUpdate()</code>。</p></div></li></ul> <h3 id="属性数据转换"><a href="#属性数据转换" class="header-anchor">#</a> 属性数据转换</h3> <p>Lit 中的默认转换器可处理<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>和<code>Object</code>类型的 prop 数据，若需要处理其他类型的数据，则可通过<code>converter</code>选项来指定一个转换器函数。使用默认转换器的方式很简单，直接在属性声明中指定<code>type</code>选项即可，若未显式指定也未通过<code>converter</code>选项自定义转换器，则默认是<code>String</code>类型。</p> <p>若设有<code>type</code>字段，则 Lit 会将 attr 的字符串值转换为指定的<code>type</code>类型的值赋给对应的 property，注意对于欲解析为引用数据类型的字符串，Lit 是直接使用的<code>JSON.parse()</code>方法转换，所以对于 JSON 字符串必须符合 JSON 规范，否则会报错。</p> <p>在 prop 值转为相应的 attr 字符串值中，若 prop 的值为<code>null</code>或<code>undefined</code>，则 Lit 会移除元素标签上对应的 attribute（对于<code>type</code>为<code>Boolean</code>的 property，只要其值为假就会移除 attribute），而引用类型数据在转为字符串值时，Lit 直接使用<code>JSON.stringify()</code>方法转换，所以对于非标准 JSON 字段或数据在转换中可能就会丢失。</p> <h4 id="自定义属性数据转换器"><a href="#自定义属性数据转换器" class="header-anchor">#</a> 自定义属性数据转换器</h4> <p>前面有提到可以通过配置<code>converter</code>选项来自定义转换器，该选项可以是一个<strong>对象或函数</strong>。</p> <p>当<code>converter</code>为对象时，其包含以下两个方法：</p> <ul><li><code>fromAttribute(value, type)</code>：该方法用于将 attr 字符串值<code>value</code>转换为指定的<code>type</code>类型 prop 值，并应该返回转换后的值，<code>type</code>可以是我们自定义的类型，比如<code>Function</code>；</li> <li><code>toAttribute(value, type)</code>：该方法用于将 prop <code>type</code>类型值<code>value</code>转换为 attr 字符串值，并应该返回转换后的值，若返回<code>null</code>或<code>undefined</code>则会从元素标签上移除该对应的 attribute。这里<code>type</code>参数可用于自行进一步验证<code>value</code>值合法性？</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    myProp<span class="token operator">:</span> <span class="token punctuation">{</span>
      converter<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">fromAttribute</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将字符串的 value 转换为 type 类型数据并返回用于映射到 prop 上</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">toAttribute</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将 type 类型的 value 转换为字符串值并返回用于映射到 attr 上</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当<code>converter</code>为函数时，其就表示<code>fromAttribute</code>函数，等同于省略<code>toAttribute</code>选项的对象简写形式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    myProp<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">converter</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 等同于 { converter: { fromAttribute: ()=&gt;{} }</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>若<code>converter</code>使用函数值，或省略<code>toAttribute</code>选项的对象值，则 Lit 使用内置的默认转换器来将 prop 值映射到 attr 上。</p> <p>个人认为这对于单向数据流的 prop 没有影响，因为我们只需要单向通过 attr 传递值到内部 prop 使用，并不更改 prop 又映射到 attr 上去，就像 vue 中的<code>props</code>与<code>v-model</code>，<code>props</code>用于单向传值，而<code>v-model</code>用于双向绑定，这可以通过配置 prop 的<code>reflect</code>选项来启用双向绑定。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>对于布尔类型的 attribute，在定义其对应的 prop 时默认值必须为<code>false</code>，若其默认值为<code>true</code>则无法通过标签将其设置为 false，因为布尔型 attr 无论是否有值，只要 attr 存在就等同于<code>true</code>。这是 Web 平台中 attr 的标准行为。</p> <p>若该标准特性不符合组件使用场景，可以使用以下方案之一改造组件：</p> <ul><li>更改 attr 为其反义名字，使其默认值为<code>false</code>，例如，HTML表单元素使用 <code>disabled</code> 属性（默认值为 <code>false</code>），而不是 <code>enabled</code>；</li> <li>使用字符串类型或数值类型的 attribute，而不是布尔类型。</li></ul></div> <h3 id="attribute反射-双向绑定"><a href="#attribute反射-双向绑定" class="header-anchor">#</a> attribute反射(双向绑定)</h3> <p>前面提到<code>attribute</code>选项只是单向映射-<strong>attr2prop</strong>，prop 虽可变化并响应内部DOM，但不会同步到 attr 上，若要实现双向绑定，则可通过配置<code>reflect</code>选项来启用将 prop 的变更同步到 attr 上-<strong>prop2attr</strong>（通过 Lit 的默认转换器或自定义的转换器）。</p> <p>单从数据交互来说，用到<code>reflect</code>选项的地方应该比较少，因为 Lit 中 attr2prop 是响应式的可触发渲染更新，而 prop 的单独修改也是响应式的可触发渲染更新，似乎<code>reflect</code>的 prop2attr 并没有必要。但在 CSS 的角度来看就不一样了，因为 attr 的变化体现在 HTML 标签上，对于 attr 的不同值可枚举的话用于 CSS 中的属性状态匹配来设置不同样式是很有用的，另一方面就是也可以适应当下 Vue 等框架组件中的<code>v-model</code>模式，方便组件外部使用同步更改的数据。</p> <p><code>reflect</code>为<code>true</code>的情况下，将<code>useDefault</code>设置为<code>true</code>会阻止 prop 的默认值在初始时同步到其相应的 attr 上，而后所有后续更改都会同步，如果该 attr 被移除，该 prop 将重置为其默认值。该效果与像元素<code>id</code>这类 attr 的行为一致，元素的<code>id</code> prop 默认值为<code>''</code>（空字符串），并且最初 HTML 上没有<code>id</code> attr，但如果设置了<code>id</code> prop（即使设置为空字符串），相应的<code>id</code> attr 也会在 HTML 上体现出来，如果移除 HTML 上<code>id</code> attr，DOM 的<code>id</code> prop 会被重置为初始值<code>''</code>。</p> <p>为确保元素按预期运行并表现良好，在应用<code>reflect</code>时尽量遵循以下最佳实践：</p> <ul><li>HTML 的 attr 应作为用户的输入来源，而不应该由元素自身控制，谨慎使用 prop2attr，尽可能考虑使用<code>:state()</code>伪类和可访问性对象模型(无障碍属性)；</li> <li>反射属性通常也应设置<code>useDefault: true</code>，因为可以防止元素自动生成用户未设置的属性，并有助于匹配预期的平台行为；</li> <li>不建议反射数据为引用类型；</li> <li>这些属性配置项并不会自行更改分配给响应式属性的值，有时原生元素会将 prop 限制为某些有效值，若为 prop 分配了无效值，该 prop 将改为设置为默认值。<code>useDefault: true</code>并不会这样做，它仅在移除 attr 时恢复默认值。如果想在 prop 赋值时更改 prop 值，可以定义并装饰一个自定义 prop 设置器 setter。</li></ul> <h3 id="自定义property访问器"><a href="#自定义property访问器" class="header-anchor">#</a> 自定义property访问器</h3> <p>默认情况下，<code>LitElement</code>类会自动为每个响应式属性定义一对 getter/setter（都属于访问器 accessor），这些 getter 和 setter 用于获取和设置属性的值，其中 setter 会自动调用<code>requestUpdate()</code>，若此时更新还未开始则立即启动更新，已开始就等下一轮。</p> <p>自定义属性的 getter/setter：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  _prop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">set</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_prop<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_prop <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token comment">// 手动调用更新，两个可选参数分别表示更新的 property，和该 property 的上一个值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requestUpdate</span><span class="token punctuation">(</span><span class="token string">'prop'</span><span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_prop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大多情况下，我们无需自定义属性访问器，只有极少数需要同步验证用户设置的任何值时可能会用到自定义设置器。若要在值更新前后做其他事，建议使用生命周期函数，比如以下两个：</p> <ul><li><code>willUpdate(changedProperties)</code>：该函数在更新前调用，<code>changedProperties</code>参数为一个<code>Map</code>对象，包含即将更改的 prop 名称和其旧值键值对；</li> <li><code>updated(changedProperties)</code>：该函数在更新后调用，参数同上。</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>当子类中存在父类已定义的响应式属性(相当于重复声明)，若未自定义访问器，Lit 默认仍会生成访问器从而覆盖父类该属性的访问器（相当于子类重新定义了，跟父类该属性的配置无关了），所以一般来说子类对该属性无特殊需求就不应该重复声明。若子类只是想更改父类上该已有属性的配置项以便适应子类的特殊需求，但并不想因此 Lit 又生成访问器覆盖父类的访问器，则可以在子类中该属性上配置<code>{ noAccessor: true }</code>来阻止 Lit 为子类该属性重新生成访问器，若要自定义访问器则无需设置改配置项。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 继承自某父类的子类中更改父类同名属性 myProp 的 type（假设父类中为 Boolean）</span>
<span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
  myProp<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number<span class="token punctuation">,</span> noAccessor<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <h3 id="自定义属性变更检测"><a href="#自定义属性变更检测" class="header-anchor">#</a> 自定义属性变更检测</h3> <p>也即是前面有提到的<code>hasChanged</code>配置项，自定义函数检测判断值是否变更，返回布尔值，若返回<code>true</code>有变更则走更新流程(响应更新的生命周期)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 设置为仅奇数认为有变化</span>
      <span class="token function">hasChanged</span><span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> hasChanged <span class="token operator">=</span> newVal <span class="token operator">!==</span> oldVal <span class="token operator">&amp;&amp;</span> newVal <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>oldVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hasChanged<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hasChanged<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="css-样式"><a href="#css-样式" class="header-anchor">#</a> CSS 样式</h2> <ul><li>编程式：通过在类中声明静态属性<code>styles</code>，并赋值为通过<code>css</code>字符串标签函数处理的 CSS 代码，这样添加的 CSS 将作用到组件内的 Shadow DOM 上（前面<code>render</code>中声明的 HTML 模板，这样定义的 HTML 和 CSS 都将渲染在组件内的 shadowRoot 根节点中，不会影响外部结构和样式）；</li> <li>声明式：通过在 HTML 模板中添加<code>&lt;style&gt;</code>标签创建内联样式，或使用<code>&lt;link&gt;</code>标签链接外部样式**(不推荐外联样式)**；</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>编程式与声明式创建的样式虽然都有效，但两者样式的存在位置是不是一样的，编程式的最终会应用到 <strong>shadowRoot</strong>，在浏览器开发者工具的 shadow tree 中是看不到的，而声明式的<code>&lt;style&gt;</code>标签就跟 shadow DOM 中的其他 HTML 标签一样是在 shadow tree 中可见的。</p></div> <p>编程式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> css<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    :host {
      color: red;
    }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;我是红色的&lt;/p&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这样添加的样式为静态样式，即不会根据组件外部进行动态处理的样式，适用于所有组件实例，大多情况下是添加样式的最佳方式。静态属性<code>style</code>的值可以是一个带<code>css</code>标签的模板字面量，也可以是这样的一组字面量<code>[css`xxx`, css`xxx`]</code>。</p></div> <p>声明式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;style&gt;
        :host {
          color: red;
        }
      &lt;/style&gt;
      &lt;p&gt;我是红色的&lt;/p&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>静态样式中也可以使用表达式，只要是同步操作就可以，但为防止恶意代码，Lit 对字符串中的表达式进行了限制，要求这些表达式本身也必须是带<code>css</code>标签的字符串或数字，若特殊情况必须使用非<code>css</code>标签字面量的表达式，并且我们可以确定该表达式来源可信，比如自己代码定义的常量，那么也可以使用<code>unsafeCSS()</code>函数包装该表达式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> primaryColor <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">blue</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> dangerColor <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">red</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token comment">// 由 css 标记的表达式可直接使用，否则需要使用 unsafeCSS 函数包裹</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    :host { color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>primaryColor<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; }
    .danger { color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">unsafeCSS</span><span class="token punctuation">(</span>dangerColor<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>上面在静态样式中使用表达式的场景来看，似乎比较适合定义一些样式常量，但若是针对定制 UI 主题，使用 CSS 变量更加合适。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>虽然声明式 CSS 中也可以使用表达式，但存在一些重要的限制和性能问题，故不推荐使用。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>由于 web components 所有内容都是在 JS 中定义的，而 CSS 中使用的<code>Unicode</code>转义字符格式为反斜杠<code>\</code>加四或六位十六进制数字(如项目符号字符<code>\2022</code>)，格式与 JS 中废弃的八进制转义格式类似，故直接在 JS 中使用会报错，为此有两种解决方案：</p> <ol><li>使用两个反斜杠，如：<code>\\2022</code>；</li> <li>使用<code>\u</code>开头，如：<code>\u2022</code>。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  div::before {
    content: '\u2022';
  }
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre></div></div> <h3 id="从父类继承样式"><a href="#从父类继承样式" class="header-anchor">#</a> 从父类继承样式</h3> <p>子类继承父类时包括<code>styles</code>这些静态属性本就会被继承，若不需要做样式修改就无需对样式进行声明，若子类也声明了<code>styles</code>静态属性，那就是对父类的重写覆盖，即使声明后赋了空值，此时相当于丢弃了父类的样式。若还要使用父类中的样式，但子类中又需要覆盖或定义一部分自己的样式，那就需要将父类的样式手动引用到当前子类中，此时其实不能称为继承了，而是复用（<strong>注意顺序，复用父类的应该在前面，自定义的应该后</strong>）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> MyParentElement <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-parent-element.js'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">MyParentElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> <span class="token punctuation">[</span>
    MyParentElement<span class="token punctuation">.</span>styles<span class="token punctuation">,</span> <span class="token comment">// 引用父类的静态样式</span>
    <span class="token comment">// 覆盖或增加一部分自己的特殊样式</span>
    css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      div {
        color: red;
      }
    </span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="共享样式"><a href="#共享样式" class="header-anchor">#</a> 共享样式</h3> <p>这里的共享样式并非常规开发中的全局样式，一份就作用于所有组件，而是指多个组件都可以引用到自己内部的共性样式，实际每个组件都会生成一份，只是来源于同一处。操作方式也就是在一个单独的 JS 模块中声明带<code>css</code>标签的样式并导出供其他需要的组件导入放在自己的静态<code>styles</code>中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// shared-styles.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> resetStyles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  p { margin: 0; }
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

<span class="token comment">// 在需要引用的组件中：</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> resetStyles <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./shared-styles.js'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> <span class="token punctuation">[</span>
    sharedStyles<span class="token punctuation">,</span>
    css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      p { color: blue; }
    </span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="动态样式class和style"><a href="#动态样式class和style" class="header-anchor">#</a> 动态样式class和style</h3> <p>这里指的是在组件内元素上动态切换<code>class</code>和<code>style</code>行内样式，需要用到 Lit 提供的额外两个指令方法--<code>classMap()</code>和<code>styleMap()</code>，可用于处理类似 Vue 中的元素<code>class</code>和<code>style</code>属性的对象结构值。</p> <p>用法示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html<span class="token punctuation">,</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> classMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit/directives/class-map.js'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> styleMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit/directives/style-map.js'</span><span class="token punctuation">;</span>
​
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    classes<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    styles<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    .someclass { border: 1px solid red; padding: 4px; }
    .anotherclass { background-color: navy; }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
​
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>classes <span class="token operator">=</span> <span class="token punctuation">{</span> someclass<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> anotherclass<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>styles <span class="token operator">=</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'lightgreen'</span><span class="token punctuation">,</span> fontFamily<span class="token operator">:</span> <span class="token string">'Roboto'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;div class=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">classMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>classes<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> style=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">styleMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>styles<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;
        Some content
      &lt;/div&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="主题样式风格"><a href="#主题样式风格" class="header-anchor">#</a> 主题样式风格</h3> <p>通过 CSS 变量来定义主题风格，对外暴露统一修改方案。</p> <h2 id="组件生命周期"><a href="#组件生命周期" class="header-anchor">#</a> 组件生命周期</h2> <h3 id="标准自定义元素生命周期"><a href="#标准自定义元素生命周期" class="header-anchor">#</a> 标准自定义元素生命周期</h3> <p>此类生命周期指的是 web 标准中定义 web components 的 class 类中规范的 5 个生命周期方法（Lit 中当然也可用）。按触发顺序分别为：</p> <ol><li><code>constructor()</code>：构造函数，在元素被<strong>创建或升级时</strong>调用（升级指的是自定义元素已先在 DOM 中存在，而元素的定义在之后才加载的情况，也就是在 HTML5 中未知元素在未定义前会被当做普通行内元素处理，而在其定义被加载解析后就会升级为自定义元素）；
<ul><li>Lit 会在此阶段调用<code>requestUpdate()</code>请求异步更新，因此在 Lit 组件升级时，其会立即更新绑定标签上相关已设置内容；</li> <li>应在此方法中设置 prop 的默认值</li></ul></li> <li><code>connectedCallback()</code>：连接回调，在元素被添加到文档的 DOM 中时调用，在该函数中应设置仅在元素连接到文档时才执行的任务（类似 Vue 中 mounted 钩子），常见的是在外部对象上添加事件监听器（如 window 或 document 上），并在元素断开连接时撤销这些任务（类似 Vue 中 beforeUnmount 钩子做的事）；
<ul><li>Lit 在元素连接后启动第一个元素更新周期。为渲染做准备时，Lit 还会确保创建 <code>renderRoot</code>（通常是其 shadowRoot），一旦某个元素至少与文档连接过一次，无论该元素的连接状态如何，组件更新都将继续进行；</li> <li>Lit 中使用该钩子时，还应该调用<code>super.connectedCallback()</code>以使用父类上的默认行为</li></ul></li> <li><code>disconnectedCallback()</code>：断开连接回调，为上面连接回调的对立面，类似 Vue 中的 beforeUnmount 钩子（不是 unmounted，因为 unmounted 是已销毁完成），应在该回调中撤销上面创建的任务（<strong>对于事件监听器，移除创建的外部事件监听器即可，对于组件内自身 DOM 上的事件监听器虚无移除，内部的不会产生影响</strong>）；
<ul><li>Lit 会在此阶段暂停响应式更新周期（Lit 独有，后面介绍），而当元素重新连接时又恢复；</li> <li>同样，Lit 中使用该钩子时，也应该调用<code>super.disconnectedCallback()</code>以使用父类上的默认行为</li></ul></li> <li><code>attributeChangedCallback()</code>：属性更改回调，当元素的某个<code>observedAttributes</code>被观察属性发生变化时调用；
<ul><li>Lit 使用此回调将 attr 的更改同步到响应式 prop。Lit 还会自动设置元素的 <code>observedAttributes</code> 数组，以匹配组件的响应式属性列表；</li> <li>由于 Lit 内部的响应式封装，很少需要手动调用这个方法</li></ul></li> <li><code>adoptedCallback()</code>：当组件移动到新文档时调用，很少使用，且该钩子没有 Polyfill 实现。
<ul><li>Lit 对此回调没有默认行为</li></ul></li></ol> <h3 id="响应式更新生命周期"><a href="#响应式更新生命周期" class="header-anchor">#</a> 响应式更新生命周期</h3> <p>这部分的生命周期钩子是 Lit 组件专有的，当响应式属性发生变化或显式调用 <code>requestUpdate()</code> 方法时，会触发响应式更新周期。Lit 异步执行更新，因此属性变化会被批量处理 —— 如果在请求更新后但更新开始前有更多属性发生变化，所有这些变化都会在同一次更新中被捕获。</p> <p>其生命周期流程图大概如下（<code>Pre-Update</code>更新前、<code>Update</code>更新中、<code>Post-Update</code>更新后）：</p> <p>客户端渲染：</p> <p><img src="/docs/assets/img/Lit-reactive-update-lifecycle.b22a06b9.jpg" alt="客户端响应式更新生命周期流程图"></p> <p>服务端渲染（其不会像上面客户端渲染调用整个更新周期，另当前 Lit 的服务端渲染正在开发中，并不完善）：</p> <p><img src="/docs/assets/img/Lit-reactive-update-lifecycle-ssr.5417f561.jpg" alt="服务端渲染响应式更新生命周期流程图"></p> <p>其中的大多<strong>响应式更新方法</strong>(主要图中的 <strong>Update 阶段</strong>)接收一个包含已更改属性的 Map（称为<code>changedProperties</code>）。Map 的键是 prop 名，其值是该 prop 之前的属性值，而对于新属性值可直接通过<code>this.prop</code> 或 this['prop'] 获取到，注意该 Map 对象包含了当前更新周期中所有发生更改的属性键值对。</p> <p>在<strong>更新期间</strong>（图中 Update 阶段，包括 <code>render()</code> 方法）更改属性仍会更新 changedProperties 映射，但<strong>不会触发新的子更新周期</strong>，可通过 changedProperties Map 在当前一轮更新周期中的后续钩子中获知相应属性也已发生变化以用于计算其他值等（同时后续钩子中也能通过上面提到的<code>this.prop</code> 或 this['prop'] 获取到变更后的新值）。而在 <code>render()</code> 之后（即图中 <strong>Post-Update 阶段</strong>，如 <code>updated()</code> 方法中）更改属性<strong>会触发一个新的更新周期</strong>，并且已更改的属性会添加到一个新的 changedProperties 映射中，以供<strong>下一个周期使用</strong>。</p> <h4 id="触发更新"><a href="#触发更新" class="header-anchor">#</a> 触发更新</h4> <p>此为 <strong>Pre-Update</strong> 更新前阶段。在响应式属性发生变化或手动调用<code>requestUpdate()</code>时，会触发更新，由于更新是异步执行的，因此在执行更新前(进入<code>Update</code>阶段前)发生的任何及所有更改只会导致一次<strong>单一更新</strong>。</p> <ul><li><code>hasChange()</code>识别为存在变化，当设置响应式属性时，Lit 内部会调用用户配置的该方法或内置该默认方法，返回<code>true</code>则会自动触发<code>requestUpdate()</code>；</li> <li><code>requestUpdate()</code>请求更新，除了上面的组件自动调用，也可手动调用该方法强制更新，这对于渲染非响应式属性产生的其他内容变化更新很有用；
<ul><li>该方法的参数可选，可传入一个属性名及其旧值，它们将以键值对形式被存在 changedProperties Map 中，若我们为某个属性提供了自定义的 getter 和 setter 方法，这可能会很有用，因为这样我们在某些生命周期的 changedProperties 参数中就可以获取到这里提供的值做其他用。</li></ul></li></ul> <h4 id="执行更新"><a href="#执行更新" class="header-anchor">#</a> 执行更新</h4> <p>此为 <strong>Update</strong> 更新中阶段。进入该阶段执行更新时，会调用<code>performUpdate()</code>方法（无需手动调用），此方法又会自动去调用其他一些生命周期方法。<strong>进入该阶段后又产生的新的所有属性更改不会又进入一个子更新周期，变更仍会反映到 changedProperties Map 中，供用户在这一轮生命周期中当前产生新更改的钩子之后剩余的生命周期方法中获取变化以手动作出响应（比如依赖其他属性的计算属性），同时也能充实例<code>this</code>上获取到相应属性变更后的新值。</strong></p> <ol><li><code>shouldUpdate()</code>钩子用于确定是否进行更新周期</li></ol> <ul><li>参数：前面提到的 changedProperties Map</li> <li>返回值：布尔值，若返回<code>true</code>则继续更新（内部默认调用时会返回<code>true</code>），若返回<code>false</code>则不会调用本轮周期中其余的更新回调，但 Post-Update 阶段中的<code>updateComplete</code>回调的 Promise 状态仍会被标记为 resolved；</li> <li>通过该钩子可以自行控制哪些属性变化会导致更新，同时可通过 changedProperties Map 来比较新旧值。<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">shouldUpdate</span><span class="token punctuation">(</span><span class="token parameter">changedProperties</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 仅在 prop1 发生了变化时允许更新</span>
  <span class="token keyword">return</span> changedProperties<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'prop1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <ol start="2"><li><code>willUpdate()</code>即将更新时钩子，会在最终更新前调用，以计算更新期间所需的依赖性值</li></ol> <ul><li>参数：changedProperties Map，返回值</li> <li>通过该钩子来计算依赖于其他属性且在 Update 阶段中后续钩子中要使用的属性值（看作 Vue 中的 watch 或 computed 理解）<div class="language-js extra-class"><pre class="language-js"><code><span class="token function">willUpdate</span><span class="token punctuation">(</span><span class="token parameter">changedProperties</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对于一些复杂数据，仅在相应依赖属性变化时才计算更新新值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>changedProperties<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'firstName'</span><span class="token punctuation">)</span> <span class="token operator">||</span> changedProperties<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'lastName'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里属于 Update 阶段中产生的属性更改，其不会触发新的子更新周期，</span>
    <span class="token comment">// 但变更会反映到 changedProperties Map 中，以供剩余钩子检测该变化或应用更改后的新值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sha <span class="token operator">=</span> <span class="token function">computeSHA</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里用到了 this.sha 新值</span>
  <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SHA: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>sha<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <ol start="3"><li><code>update()</code>更新 DOM 钩子，会将 prop 值同步到 attr，并调用 <code>render()</code> 钩子更新组件内部 DOM
<ul><li>参数：changedProperties Map，无需返回值</li> <li><strong>需要调用父类 <code>super.update()</code> 原始方法，否者不会同步 attr 和更新 DOM</strong></li> <li>通常情况下，无需重写该钩子</li></ul></li> <li><code>render()</code>渲染钩子，为组件提供 HTML 模板，由<code>update()</code>内部调用
<ul><li>参数：无</li> <li>返回值：HTML 模板</li></ul></li></ol> <h4 id="完成更新"><a href="#完成更新" class="header-anchor">#</a> 完成更新</h4> <p>在调用<code>update()</code>将更改渲染到组件的 DOM 后，便可以使用该阶段（Post-Update）的这些钩子对组件最新 DOM 执行操作了，<strong>此阶段中新的属性更改会进入下一轮新的更新生命周期</strong>。</p> <ol><li><code>firstUpdated()</code> DOM 首次更新完成钩子，注意仅在组件 DOM 首次更新后，且浏览器有机会进行绘制前调用，不会每轮更新周期都调用
<ul><li>参数：changedProperties Map，无需返回值</li> <li>可在该钩子中处理组件 DOM 创建后的一次性工作，比如聚焦于内部某特定渲染元素，或向内部某元素添加<code>ResizeObserver</code>或<code>IntersectionObserver</code>等监听，听上去似乎与前面自定义元素的标准生命周期钩子<code>connectedCallback()</code>类似，实际不同的是<code>firstUpdated()</code>应该在<code>connectedCallback()</code>之后，其包括了相关 attr 和 prop 初始化同步后的 DOM 状态，而<code>connectedCallback()</code>只是自定义元素 DOM 插入了文档，相关属性可能还没同步好。</li></ul></li> <li><code>updated()</code> DOM 更新完成钩子，元素的 DOM 已更新并渲染时调用，每轮组件更新完成都会调用
<ul><li>参数：changedProperties Map，无需返回值</li> <li>可在该钩子中处理 DOM 更新后的工作，如动画。</li></ul></li> <li><code>updateComplete</code> 这是一个表示更新完成状态的 Promise 对象，当一轮更新周期完成后没有待处理的更新了，其状态就会变成 resolved，并返回 <code>true</code>，若更新周期中存在为捕获处理的错误，则其庄涛就会变为 rejected
<ul><li>注意，<strong>其不是一个函数调用然后返回 Promise，而本身就是一个 Promise</strong>，所以不能函数方式调用；</li> <li>可通过 <code>await this.updateComplete</code> 来等待更新周期完成，也可设置回调<code>this.updateComplete.then(() =&gt; { ... })</code>等待完成；</li> <li>更新完成状态并不会等待其任何子元素也完成其更新(若存在子元素依赖父元素变化的情况，注意这里是 light DOM 中的子元素，不是 shadow DOM 中的父子元素)，如果自定义其状态变化行为，可通过重写<code>getUpdateComplete()</code>方法实现；</li> <li>需要知道元素更新何时完成的情况主要有以下几种：
<ul><li>编写组件内测试时，对组件 DOM 进行断言(判断组件DOM状态满足某条件否)前等待<code>updateComplete</code>状态，若断言依赖于组件所有后代元素，则等待<code>requestAnimationFrame</code>更好，因为 Lit 默认适用微任务队列，该队列在动画帧之前被清空；</li> <li>需要测量 DOM 尺寸以实现特定布局时，以保证 DOM 状态已最新且稳定，但若要等待所有后代元素也完成更新，建议使用<code>ResizeObserver</code> API 更可靠；</li> <li>渲染完成后从组件派发自定义事件时，这样可说的事件监听器获取到组件的完整渲染状态。</li></ul></li></ul></li></ol> <h4 id="更新周期中的错误处理"><a href="#更新周期中的错误处理" class="header-anchor">#</a> 更新周期中的错误处理</h4> <p>若在 Update 更新中阶段的生命周期钩子内有未捕获的异常，则会导致<code>updateComplete</code>状态变为 rejected，好的做法是若在生命周期钩子中能预见可能抛出异常的代码，则最好都使用<code>try/catch</code>进行捕获处理。若未预处可能的异常，在等待<code>updateComplete</code> Promise 状态时，建议也使用<code>try/catch</code>进行捕获处理。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>updateComplete<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cnosole<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">'处理错误'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在某些情况下，代码可能在意想不到的地方抛出错误，作为一种备选方案，可在<code>window</code>对象上添加<code>unhandledrejection</code>事件（<strong>JS原生事件</strong>，用于捕获所有未<code>catch()</code>的 Promise rejected 异常）来捕获这些问题。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onunhandledrejection</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">'处理未捕获的 Promise rejected'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'unhandledrejection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">'处理未捕获的 Promise rejected'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="不常用的更新生命周期钩子"><a href="#不常用的更新生命周期钩子" class="header-anchor">#</a> 不常用的更新生命周期钩子</h4> <p>本节介绍一般不常会去自定义重写的更新生命周期钩子，其中有前面提到但未详细介绍的，也有未提到的。</p> <ul><li><code>scheduleUpdate()</code>：调度更新钩子，在即将执行更新时(指进入 Update 阶段)被调用，默认情况下其会立即调用<code>performUpdate()</code>，重写该钩子可用于解除对主渲染/事件线程的阻塞（设法延后更新时机），但须注意<strong>别忘了调用原始钩子</strong><code>super.scheduleUpdate()</code> <ul><li>例如将更新安排在下一帧绘制后进行，若更新开销大，这样做可减少卡顿<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里使用 async/await 声明为异步函数隐式返回一个 Promise，也可以声明为普通函数显式返回一个 Promise</span>
<span class="token keyword">async</span> <span class="token function">scheduleUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">scheduleUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用原始钩子，以衔接内部处理流程</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><code>performUpdate()</code>：执行更新钩子，在调度更新后被调用，实现响应式更新循环，并调用其他钩子，调用该钩子可立即处理待处理的更新，通常情况下无需这样做，但极少需要同步更新的情况下可以这么操作。
<ul><li>若没有待处理的更新，可先调用<code>requestUpdate()</code>，然后调用<code>performUpdate()</code>来强制进行同步更新</li></ul></li> <li><code>hasUpdated</code>：是否更新过，此为普通属性，而非钩子方法也非 Promise 对象，若组件至少更新过一次，则该属性将返回<code>true</code>，可在任何生命周期钩子中访问该属性，以便仅在组件尚未更新过时执行操作；</li> <li><code>getUpdateComplete()</code>：获取更新完成状态的 Promise 对象，其返回的 Promise 会同步给<code>updateComplete</code>属性，若要在<code>updateComplete</code> Promise resolved 前等待其他条件，则可重写该方法。
<ul><li>比如除了原本的仅等待当前组件本身 DOM 更新完成外，还要求等待其子元素也更新完成，才算当前组件真的更新完成时：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">getUpdateComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getUpdateComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待当前组件 shadow DOM 更新完成</span>
    <span class="token comment">// await Promise.all(this.shadowRoot.querySelectorAll('*').map(el =&gt; el.updateComplete));</span>
    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_myChild<span class="token punctuation">.</span>updateComplete<span class="token punctuation">;</span> <span class="token comment">// 等待某个子元素也更新完成</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment">// 返回原始结果，以保持原有行为</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="外部生命周期钩子"><a href="#外部生命周期钩子" class="header-anchor">#</a> 外部生命周期钩子</h3> <p>该部分主要针对控制器和装饰器，可根据需要查看原文档。</p> <h2 id="shadow-dom"><a href="#shadow-dom" class="header-anchor">#</a> Shadow DOM</h2> <p>Lit 将组件渲染到 <code>renderRoot</code> 属性上，默认情况下其就是自定义元素的 <code>shadowRoot</code>，其是一个<code>ShadowRoot</code>实例，而<code>ShadowRoot</code>的原型指向<code>DocumentFragment</code>，因此可将其理解成组件内的<code>document</code>，也就具备一些共同的 API。</p> <h3 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h3> <p>默认情况下，若一个元素有 shadow tree，则其在 light DOM 中的后端元素根本不会渲染，只有该元素单的 shadow tree 中设置了<code>&lt;slot&gt;</code>插槽，且 light DOM 中有正确传入插槽中的后代元素才会被渲染。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>传入插槽的元素，其自身不会被移动到 shadow DOM 中，只是如同<code>&lt;slot&gt;</code>的子元素一样被渲染在相应位置，其在 light DOM 中位置是保持原样的，跟其他普通元素的使用关系一样。</p></div> <p>要访问分配到<code>shadowRoot</code>中插槽的后代元素，可使用 web 标准的 <code>slot.assignedNodes()</code> 或 <code>slot.assignedElements()</code> 方法以及 <code>slotchange</code> 事件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过一个 getter 获取插槽的子元素</span>
  <span class="token keyword">get</span> <span class="token function">_slottedChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> slot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shadowRoot<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'slot'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> slot<span class="token punctuation">.</span><span class="token function">assignedElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 通过 slotchange 事件处理函数获取插槽的子元素</span>
  <span class="token function">handleSlotchange</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> childNodes <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">assignedNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里示例提取所有被插槽化子项的文本内容。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>allText <span class="token operator">=</span> childNodes<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>textContent <span class="token operator">?</span> node<span class="token punctuation">.</span>textContent <span class="token operator">:</span> <span class="token string">''</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;
      &lt;slot @slotchange=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSlotchange<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;&lt;/slot&gt;
      &lt;p&gt;插槽文本内容：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>allText<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;
    &lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>传入的元素仅在插槽渲染后才会获取到，若需要在启动时访问这些元素，则需要等待 <code>firstUpdated</code> 或 <code>updated</code>，若想在渲染发生变化时访问这些元素，则可以使用 <code>slotchange</code> 事件。</p></div> <h3 id="自定义渲染根节点-shadowroot"><a href="#自定义渲染根节点-shadowroot" class="header-anchor">#</a> 自定义渲染根节点 shadowRoot</h3> <p>每个原生自定义元素都有一个 shadow root 根节点，Lit 组件自然也不例外，默认情况下，<code>LitElement</code> 创建一个开放的 <code>shadowRoot</code> 并在其中进行渲染，有两种方式自定义<code>LitElement</code>的根节点渲染方式：</p> <ul><li>设置静态属性<code>shadowRootOptions</code>，以更改<code>LitElement</code>内创建<code>shadowRoot</code>时的配置项；</li> <li>自定义<code>createRenderRoot()</code>方法，并返回希望模板渲染到的根节点。</li></ul> <h4 id="设置静态属性shadowrootoptions"><a href="#设置静态属性shadowrootoptions" class="header-anchor">#</a> 设置静态属性<code>shadowRootOptions</code></h4> <p>自定义渲染根的最简单方法是设置 <code>shadowRootOptions</code> 静态属性。<code>createRenderRoot()</code> 的默认实现会在创建组件的 shadow root 时，将 <code>shadowRootOptions</code> 作为选项参数传递给原生 <code>attachShadow()</code> 方法，因此可以通过设置该选项来定制 ShadowRootInit 字典中允许的任何选项，例如 <code>mode</code> 和 <code>delegatesFocus</code>，可参考原生 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/attachShadow" target="_blank" rel="noopener noreferrer">Element.attachShadow()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 方法的参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">DelegatesFocus</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">// 因该属性为静态属性，因为只能通过类来访问原始配置参数，这里增加了使用焦点委托的选项</span>
  <span class="token keyword">static</span> shadowRootOptions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>LitElement<span class="token punctuation">.</span>shadowRootOptions<span class="token punctuation">,</span> delegatesFocus<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="自定义createrenderroot-方法"><a href="#自定义createrenderroot-方法" class="header-anchor">#</a> 自定义<code>createRenderRoot()</code>方法</h4> <p><code>createRenderRoot()</code> 的默认实现会创建一个开放的（<code>mode</code>为<code>open</code>）shadow root 影子根节点，并将 <code>styles</code> 静态属性设置的样式添加到该节点，若要自定义<code>createRenderRoot()</code>方法，需要返回一个希望渲染到的位置根节点。</p> <p>例如将模板内容作为自定义元素的子元素渲染到 light DOM 中，则直接在<code>createRenderRoot()</code>方法，返回<code>this</code>对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">LightDom</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;p&gt;Custom rendering without shadow DOM (note, styling leaks in).&lt;/p&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">createRenderRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此时使用该 shadow host 元素本身作为模板渲染根节点，因此上面的 HTML 模板会直接渲染在 light DOM 中当前自定义元素内，而不是其 shadow DOM 中</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>不建议将模板渲染到子元素而不是 shadow DOM 中，这样实际是渲染在 light DOM 中，样式作用域无法生效，还会受外部样式影响，也无法将元素组合到内部 DOM 中，失去了组件的封装性。</p></div> <h2 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h2> <p>在 Lit 中，除了标准的事件监听 web API <code>addEventListener()</code>外，还可在 HTML 模板中使用类似 Vue 中的声明式添加事件监听器的方式，即 <code>@eventname=&quot;${this._handlerName}&quot;</code>，包括自定义事件（但仅限 Lit 组件的HTML模板中使用该语法），其会在模板<code>render()</code>渲染时被转换，若给<code>@eventname</code>传递的值为<code>null</code>或<code>undefined</code>或空内容，则会移除该事件监听器。注意这里的<code>eventname</code>事件名是事件声明的原始格式，不能做任何转换，如自定义的事件名为<code>my-event</code>，那就只能写成<code>@my-event</code>（虽然内部一般不会监听自定义事件，一般都是派发给外部使用的）。</p> <h3 id="自定义事件监听器选项"><a href="#自定义事件监听器选项" class="header-anchor">#</a> 自定义事件监听器选项</h3> <p>若要在声明式事件注册中自定义事件监听器选项（即<code>addEventListener()</code>方法的第三个参数为对象时提供的可选配置项--<code>capture/once/passive/signal</code>），则需要向模板中的事件监听器表达式传递一个对象的方式来配置需要的选项，且该对象必须有一个<code>handleEvent()</code>方法表示时间处理器(注意使用箭头函数使<code>this</code>指向正确)，而其他选项就是前面提到的可选配置项。</p> <h3 id="向元素本身或showroot添加事件监听器"><a href="#向元素本身或showroot添加事件监听器" class="header-anchor">#</a> 向元素本身或showRoot添加事件监听器</h3> <ul><li>由于自定义元素类声明中的<code>this</code>即指向每个元素实例本身，故直接在<code>constructor()</code>向<code>this</code>添加事件监听也就是在 shadow host 上添加了，此时与在 light DOM 中该自定义元素上添加的事件一样，即使事件触发是 shadow DOM 中的元素，其事件源<code>event.target</code>也是指向 shadow host 元素本身，等同于<code>event.currentTarget</code>当前绑定事件的元素，不会深入 shadow DOM 中的元素（注意light DOM 中传入的插槽内容并不属于 shadow DOM 内容）；</li> <li>在<code>shadowRoot</code>(Lit 中也可以使用<code>renderRoot</code>)上添加的事件监听器属于 shadow DOM 内部监听，其事件源<code>event.target</code>会指向实际触发的元素（事件委托机制），包括 shadow DOM 和 light DOM 传入的插槽内容。由于<code>shadowRoot</code>需要组件更新渲染后才有实际值，所以添加事件监听应该在<code>connectedCallback()</code>或<code>firstUpdated()</code>中进行，或是在<code>createRenderRoot()</code>中获取<code>shadowRoot</code>并添加事件监听（须注意返回原始根节点）。</li></ul> <h3 id="给-shadow-dom-之外内容添加事件"><a href="#给-shadow-dom-之外内容添加事件" class="header-anchor">#</a> 给 shadow DOM 之外内容添加事件</h3> <p>向组件 shadow DOM 之外的任何对象添加事件监听器（如<code>window</code>、<code>document</code>或 light DOM 中的某元素），则应该在<code>connectedCallback()</code>中添加，并在<code>disconnectedCallback()</code>中移除。在<code>connectedCallback()</code>(而不是<code>constructor()</code>或<code>firstUpdated()</code>等)中添加事件可确保若组件从 DOM 中断开连接并随后重新连接时，其将重新创建对应的事件监听器（实际前面括号提到的钩子中也行，但还是需要在<code>disconnectedCallback()</code>中做相应的移除，但从配对关系上来说肯定<code>connectedCallback()</code>更合适）。<strong>对于这种向组件外部对象添加事件的情况，其处理函数应该只处理与当前组件实例相关的事务，避免处理公共事务，除非能保证同一界面视图下只用到一次该组件，否则就会导致重复添加公共事务处理事件。</strong></p> <h3 id="派发自定义事件"><a href="#派发自定义事件" class="header-anchor">#</a> 派发自定义事件</h3> <p>所有 DOM 节点都可以使用标准 Web API <code>dispatchEvent()</code> 方法派发自定义事件，自定义事件根据不同使用场景可以通过<code>Event</code>类或其标准子类（如<code>CustomEvent/MouseEvent/KeyboardEvent/InputEvent</code>等等）以及在这些标准类上自行扩展的子类来创建，并通过传递第二个参数来配置事件对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 不携带数据，仅做通知的事件用 Event 类</span>
<span class="token keyword">let</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">'my-event'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> bubbles<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> composed<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 要自定义数据的事件用 CustomEvent 类，其提供 detail 选项传递数据，可在监听器回调中的事件对象上获取到传递的该属性数据</span>
event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'my-event'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> composed<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> detail<span class="token operator">:</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// （不推荐）基于某事件类型创建，其提供了与该类型事件匹配的额外数据配置项，特别是在覆盖标准事件时，这会很有用，例如自定义 click 事件时，但其可能导致标准事件的一些默认浏览器行为丢失，比如自定义 focus 可能导致元素本身的聚焦表现失效</span>
event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MouseEvent</span><span class="token punctuation">(</span><span class="token string">'my-event'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> composed<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建子类扩展更多接口</span>
<span class="token keyword">class</span> <span class="token class-name">MyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">'my-event'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> composed<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 自定义接口</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEvent</span><span class="token punctuation">(</span><span class="token string">'自定义接口'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 派发事件</span>
el<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在实例化自定义事件时，对于第二个配置对象中的部分选项需要重点注意（全量可查看 MDN 文档）：</p> <ul><li><code>bubbles</code>：是否允许冒泡，允许冒泡就可以被祖先元素捕获该事件（包括 shadow DOM 和 light DOM 中，light DOM 中还需要事件可以穿透），默认 false；</li> <li><code>composed</code>：是否允许事件穿透到 shadow DOM 之外，默认 false，允许穿透则可以在外部 light DOM 中捕获该事件，否则即使允许冒泡也只能在 shadow DOM 中冒泡，<strong>须注意该选项与冒泡选项没有必然联系，其只是决定是否将内部派发的事件提升到 shadow host 这一层，即决定了是否可以在该自定义元素本身上捕获该自定义事件，其对于冒泡的影响就是是否阻断在 light DOM 中继续冒泡，即使不冒泡，允许穿透则该自定义元素自身上也还是可以捕获该事件</strong>；</li></ul> <p>若派发的自定义事件仅允许 light DOM 中该 shadow host 元素自身捕获，则从 shadow DOM 内派发的事件选项应该设置为<code>{ omposed: true }</code>（若某些情况下事件回调中仍要知道实际事件源，可调用<code>event.composedPath()</code>方法，其返回事件穿透路径中所有节点数组，第一个就是最底层的元素，包括 shadow DOM 中的元素），而直接从 shadow host <code>this</code> 上派发的则事件选项都使用默认值<code>false</code>（因此时直接在宿主元素自身上，也就不在乎是否冒泡和穿透了），从组件的封装性上来说，这是最合适的。</p> <p>像 Vue 中一样，常规标准事件一般不需要去自定义，除非是将内部子元素上的特殊事件转移到组件本身上，比如将内部 <code>&lt;input&gt;</code> 的 <code>input</code> 事件转移到对外的自定义元素 <code>&lt;my-input&gt;</code> 上。</p> <h3 id="事件派发时机"><a href="#事件派发时机" class="header-anchor">#</a> 事件派发时机</h3> <p>事件应该在响应用户交互或组件状态的异步变化时触发，不应该在开发者自己控制组件 attr 或 prop 值进行的变化时触发，这符合 web 标准元素的工作方式，因为直接设置这些值时，值的变化都掌握在开发者自己手里，而不是外部用户的行为，开发者可以在更改值时同步调用后续处理逻辑，而不是去触发事件，比如用户在原生<code>&lt;input&gt;</code>中完成输入后会触发<code>change</code>事件，但若是开发者代码直接设置的<code>&lt;input&gt;</code>的<code>value</code>属性，则不会触发<code>change</code>事件，但开发者可以自己同步调用 change 逻辑，而对于组件封装清空输入这种边界状态的变化，若我们提供了<code>clear</code>方法或快捷操作，可以去手动触发<code>change</code>事件。<strong>一般来说，一个自定义事件应该是在其他标准事件的监听回调中被派发的。</strong></p> <p>通常，一个事件若是跟元素的状态表现有关，那该事件应该仅在元素更新并渲染后触发，以便符合用户视觉感受，因为响应式是异步的，数据变化后若与视觉状态变化间隔长，一开始就派发了事件，用户感知就会错位，而且事件回调也可能不能立即获取到 DOM 的最新状态。这种情况下，可以在更改数据状态后但派发事件前等待组件的 <code>updateComplete</code> Promise resolve。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token function">_notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>open <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>open<span class="token punctuation">;</span>
  <span class="token comment">// 等 DOM 更新完成</span>
  <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>updateComplete<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'toggle'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> detail<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>open <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>open <span class="token operator">?</span> <span class="token string">'opened'</span> <span class="token operator">:</span> <span class="token string">'closed'</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="事件派发器与监听器间的通信"><a href="#事件派发器与监听器间的通信" class="header-anchor">#</a> 事件派发器与监听器间的通信</h3> <p>这两者间的通信主要指：派发器即调用<code>dispatchEvent()</code>后获取监听器回传的数据，监听器即事件回调中获取派发器传递的数据。</p> <ul><li>一种实现方式就是在事件上公开API，这样两边都可以访问和修改改API，比如两者都可以通过更改事件对象上的<code>datail</code>字段来传递数据，也可以像前面提到扩展事件接口来传递。</li> <li>还有一种就是通过<code>preventDefault()</code>方法，调用该方法表示不执行事件的默认操作，且事件的<code>defaultPrevented</code>属性会同步变为`true，然后调度器中也可以根据该属性的状态来判断是否执行默认操作。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调度器向监听器传递数据较常见，前面也有提到方式，这里主要给出监听器向调度器回传数据的示例</span>
<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">// 假设这是 shadow DOM 中的一个标准事件的回调函数</span>
  <span class="token function">_tryChange</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'checked'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token comment">// 自定义传给外部监听器的数据</span>
      detail<span class="token operator">:</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 外部监听器是否阻止默认行为</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>defaultPrevented<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 这里的 detail 数据也可以被外部监听器修改，从而反应到派发器这里（只要是同步操作）</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="综合示例"><a href="#综合示例" class="header-anchor">#</a> 综合示例</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number <span class="token punctuation">}</span><span class="token punctuation">,</span>
    _btnNum<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number<span class="token punctuation">,</span> state<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_btnNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 构造时即可在 host 上绑定事件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'host'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>type<span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>localName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模板字符串中属性值的引号可省略（html 标记函数会正确处理）</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;p&gt;
        &lt;button @click=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_increment<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;点我&lt;/button&gt;
        &lt;button @click=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_handleObj<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;剩余 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_btnText<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 次&lt;/button&gt;
        &lt;span&gt;点击次数：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/span&gt;
      &lt;/p&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">createRenderRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// createRenderRoot() 中是最早给 shadowRoot/renderRoot 属性赋值的位置</span>
    <span class="token comment">// 由于我们并不是要重新生成渲染根节点，只是要获取根节点使用而已，故调用原始创建渲染根节点方法</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">createRenderRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在 shadowRoot 上注册事件</span>
    root<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
      <span class="token string">'click'</span><span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'createRenderRoot'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>type<span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>localName<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 注意必须返回渲染根节点</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">async</span> <span class="token function">firstUpdated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// showRoot/renderRoot 上添加监听事件须保障该属性已赋值，且不要放在 update() 中，否则会每次更新都添加一次监听</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>shadowRoot<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'shadowRoot'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>type<span class="token punctuation">,</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>localName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 为确保用户能看到组件后再添加监听器，可等待浏览器完成绘制后异步添加事件监听</span>
    <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>renderRoot<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async firstUpdated'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">_increment</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 派发自定义事件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> detail<span class="token operator">:</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  _handleObj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里使用箭头函数，否则 this 未指向当前组件实例</span>
    <span class="token function-variable function">handleEvent</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_btnNum<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    once<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/js/WebComponents.html" class="prev">
        Web Components
      </a></span> <span class="next"><a href="/docs/js/File文件API.html">
        File文件API
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/docs/assets/js/app.148f908e.js" defer></script><script src="/docs/assets/js/2.23b2ce06.js" defer></script><script src="/docs/assets/js/14.c0bae6d1.js" defer></script>
  </body>
</html>
