<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lit 框架创建 Web Components | Notebook</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/docs/favicon.ico">
    <meta name="description" content="个人学习记录，资料收集备忘">
    
    <link rel="preload" href="/docs/assets/css/0.styles.55326b6c.css" as="style"><link rel="preload" href="/docs/assets/js/app.08fe61ab.js" as="script"><link rel="preload" href="/docs/assets/js/2.7cd822c1.js" as="script"><link rel="preload" href="/docs/assets/js/33.0386436d.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.72a9314c.js"><link rel="prefetch" href="/docs/assets/js/11.b2108865.js"><link rel="prefetch" href="/docs/assets/js/12.2c1b2ec9.js"><link rel="prefetch" href="/docs/assets/js/13.c33a225a.js"><link rel="prefetch" href="/docs/assets/js/14.2e22b71a.js"><link rel="prefetch" href="/docs/assets/js/15.dbc68ef0.js"><link rel="prefetch" href="/docs/assets/js/16.84457c51.js"><link rel="prefetch" href="/docs/assets/js/17.52e5273d.js"><link rel="prefetch" href="/docs/assets/js/18.67d4515e.js"><link rel="prefetch" href="/docs/assets/js/19.940b4d57.js"><link rel="prefetch" href="/docs/assets/js/20.e377c5fb.js"><link rel="prefetch" href="/docs/assets/js/21.0c2fa396.js"><link rel="prefetch" href="/docs/assets/js/22.e1c082b5.js"><link rel="prefetch" href="/docs/assets/js/23.4ed3dada.js"><link rel="prefetch" href="/docs/assets/js/24.bd188c1f.js"><link rel="prefetch" href="/docs/assets/js/25.3ad8c116.js"><link rel="prefetch" href="/docs/assets/js/26.33ee5580.js"><link rel="prefetch" href="/docs/assets/js/27.e7cc24c9.js"><link rel="prefetch" href="/docs/assets/js/28.837948e7.js"><link rel="prefetch" href="/docs/assets/js/29.410abe44.js"><link rel="prefetch" href="/docs/assets/js/3.7564b2ae.js"><link rel="prefetch" href="/docs/assets/js/30.cc8eb36b.js"><link rel="prefetch" href="/docs/assets/js/31.7c16d041.js"><link rel="prefetch" href="/docs/assets/js/32.817dddd2.js"><link rel="prefetch" href="/docs/assets/js/34.d0315127.js"><link rel="prefetch" href="/docs/assets/js/35.302cd8ff.js"><link rel="prefetch" href="/docs/assets/js/36.105713b6.js"><link rel="prefetch" href="/docs/assets/js/37.65981373.js"><link rel="prefetch" href="/docs/assets/js/38.f91f63d4.js"><link rel="prefetch" href="/docs/assets/js/39.94ac212c.js"><link rel="prefetch" href="/docs/assets/js/4.f9012dd0.js"><link rel="prefetch" href="/docs/assets/js/40.c15edce9.js"><link rel="prefetch" href="/docs/assets/js/41.2d96d1ec.js"><link rel="prefetch" href="/docs/assets/js/42.70498ef4.js"><link rel="prefetch" href="/docs/assets/js/43.d3df4473.js"><link rel="prefetch" href="/docs/assets/js/44.76241211.js"><link rel="prefetch" href="/docs/assets/js/45.0b20b42d.js"><link rel="prefetch" href="/docs/assets/js/46.e23cf554.js"><link rel="prefetch" href="/docs/assets/js/47.92531c48.js"><link rel="prefetch" href="/docs/assets/js/48.f6a9e1fe.js"><link rel="prefetch" href="/docs/assets/js/49.85b5c3fc.js"><link rel="prefetch" href="/docs/assets/js/5.7340601b.js"><link rel="prefetch" href="/docs/assets/js/50.3bd81e89.js"><link rel="prefetch" href="/docs/assets/js/51.965ef0ca.js"><link rel="prefetch" href="/docs/assets/js/52.9cf46b5a.js"><link rel="prefetch" href="/docs/assets/js/53.ca6c3d21.js"><link rel="prefetch" href="/docs/assets/js/54.7ef7e175.js"><link rel="prefetch" href="/docs/assets/js/55.41c8c4ed.js"><link rel="prefetch" href="/docs/assets/js/56.4dbd7929.js"><link rel="prefetch" href="/docs/assets/js/57.5436677e.js"><link rel="prefetch" href="/docs/assets/js/58.f1bcf78a.js"><link rel="prefetch" href="/docs/assets/js/59.5387950c.js"><link rel="prefetch" href="/docs/assets/js/6.d4f121f4.js"><link rel="prefetch" href="/docs/assets/js/60.403907d4.js"><link rel="prefetch" href="/docs/assets/js/61.c6417a83.js"><link rel="prefetch" href="/docs/assets/js/62.74a3e44c.js"><link rel="prefetch" href="/docs/assets/js/63.b94e6886.js"><link rel="prefetch" href="/docs/assets/js/64.1f4516ae.js"><link rel="prefetch" href="/docs/assets/js/65.113e7bc2.js"><link rel="prefetch" href="/docs/assets/js/66.5d250d0c.js"><link rel="prefetch" href="/docs/assets/js/67.8f0f3cb7.js"><link rel="prefetch" href="/docs/assets/js/68.9f25558d.js"><link rel="prefetch" href="/docs/assets/js/69.8f2327aa.js"><link rel="prefetch" href="/docs/assets/js/7.198cac72.js"><link rel="prefetch" href="/docs/assets/js/70.c1e17b8c.js"><link rel="prefetch" href="/docs/assets/js/71.ae9a423c.js"><link rel="prefetch" href="/docs/assets/js/72.f10ab930.js"><link rel="prefetch" href="/docs/assets/js/73.96be54ce.js"><link rel="prefetch" href="/docs/assets/js/74.b32342f8.js"><link rel="prefetch" href="/docs/assets/js/75.bdf322be.js"><link rel="prefetch" href="/docs/assets/js/76.cc59617c.js"><link rel="prefetch" href="/docs/assets/js/77.887d7f63.js"><link rel="prefetch" href="/docs/assets/js/78.25d8ca21.js"><link rel="prefetch" href="/docs/assets/js/79.e600fecb.js"><link rel="prefetch" href="/docs/assets/js/8.70a01d30.js"><link rel="prefetch" href="/docs/assets/js/80.039e7dbf.js"><link rel="prefetch" href="/docs/assets/js/81.cb600c59.js"><link rel="prefetch" href="/docs/assets/js/9.d47db3aa.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.55326b6c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><img src="/docs/logo.png" alt="Notebook" class="logo"> <span class="site-name can-hide">Notebook</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记分类" class="dropdown-title"><span class="title">笔记分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记分类" class="mobile-dropdown-title"><span class="title">笔记分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/docs/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="https://wanje.github.io/demo_notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记分类" class="dropdown-title"><span class="title">笔记分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记分类" class="mobile-dropdown-title"><span class="title">笔记分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/js/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/docs/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/docs/css/" class="nav-link">
  CSS
</a></li></ul></div></div><div class="nav-item"><a href="https://wanje.github.io/demo_notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/html/HTML零散集.html" class="sidebar-link">HTML零散集</a></li><li><a href="/docs/html/a标签的各种用途.html" class="sidebar-link">a标签的各种用途</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/js/JS错题本.html" class="sidebar-link">JS错题本</a></li><li><a href="/docs/js/JS零散集.html" class="sidebar-link">JS零散集</a></li><li><a href="/docs/js/数组Array.html" class="sidebar-link">数组Array</a></li><li><a href="/docs/js/字符串String.html" class="sidebar-link">字符串String</a></li><li><a href="/docs/js/计算Math.html" class="sidebar-link">计算Math</a></li><li><a href="/docs/js/事件Event.html" class="sidebar-link">事件Event</a></li><li><a href="/docs/js/WebComponents.html" class="sidebar-link">Web Components</a></li><li><a href="/docs/js/Lit创建WebComponents.html" class="active sidebar-link">Lit 框架创建 Web Components</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#定义元素" class="sidebar-link">定义元素</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#渲染内容" class="sidebar-link">渲染内容</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#响应式属性" class="sidebar-link">响应式属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#变更对象和数组属性" class="sidebar-link">变更对象和数组属性</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#属性数据转换" class="sidebar-link">属性数据转换</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#attribute反射-双向绑定" class="sidebar-link">attribute反射(双向绑定)</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义property访问器" class="sidebar-link">自定义property访问器</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#自定义属性变更检测" class="sidebar-link">自定义属性变更检测</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#css-样式" class="sidebar-link">CSS 样式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#从父类继承样式" class="sidebar-link">从父类继承样式</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#共享样式" class="sidebar-link">共享样式</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#动态样式class和style" class="sidebar-link">动态样式class和style</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#主题样式风格" class="sidebar-link">主题样式风格</a></li></ul></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#组件生命周期" class="sidebar-link">组件生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#标准自定义元素生命周期" class="sidebar-link">标准自定义元素生命周期</a></li><li class="sidebar-sub-header"><a href="/docs/js/Lit创建WebComponents.html#响应式更新生命周期" class="sidebar-link">响应式更新生命周期</a></li></ul></li></ul></li><li><a href="/docs/js/File文件API.html" class="sidebar-link">File文件API</a></li><li><a href="/docs/js/鼠标拖放与拖拽dnd.html" class="sidebar-link">鼠标拖拽与拖放</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>ES6+</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/js/es6+/Class.html" class="sidebar-link">Class</a></li><li><a href="/docs/js/es6+/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/docs/js/es6+/async-await.html" class="sidebar-link">async/await</a></li><li><a href="/docs/js/es6+/Proxy.html" class="sidebar-link">Proxy</a></li><li><a href="/docs/js/es6+/Reflect.html" class="sidebar-link">Reflect</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS零散集.html" class="sidebar-link">CSS零散集</a></li><li><a href="/docs/css/scss语法.html" class="sidebar-link">SCSS基础语法</a></li><li><a href="/docs/css/CSS选择器世界.html" class="sidebar-link">CSS选择器世界</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>CSS世界</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS世界/层叠规则.html" class="sidebar-link">层叠规则</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>CSS新世界</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/css/CSS新世界/第6章.html" class="sidebar-link">第 6 章 全新的布局方式</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>绘图&amp;动画</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/draw-animation/D3js.html" class="sidebar-link">D3.js</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Threejs开发指南</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/vue/vue工程配置.html" class="sidebar-link">Vue工程创建及配置</a></li><li><a href="/docs/vue/vue基础语法.html" class="sidebar-link">Vue基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/react/react工程配置.html" class="sidebar-link">React工程创建及配置</a></li><li><a href="/docs/react/react基础语法.html" class="sidebar-link">React基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/typescript/类型/为什么需要类型.html" class="sidebar-link">为什么需要类型</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>类型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>泛型</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>类型转换</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/docs/typescript/模块/CommonJS兼容模块.html" class="sidebar-link">CommonJS兼容模块</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>命名空间</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>理解声明</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/node/Node模块机制.html" class="sidebar-link">Node模块机制与NPM包</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/webpack/webpack4.x笔记.html" class="sidebar-link">webpack4.x笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Python</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/python/python基础语法.html" class="sidebar-link">Python基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/others/参考内容.html" class="sidebar-link">参考内容</a></li><li><a href="/docs/others/lint-format.html" class="sidebar-link">代码检查与格式化</a></li><li><a href="/docs/others/Markdown语法.html" class="sidebar-link">Markdown语法</a></li><li><a href="/docs/others/Git使用.html" class="sidebar-link">Git使用</a></li><li><a href="/docs/others/Gulp使用.html" class="sidebar-link">Gulp使用</a></li><li><a href="/docs/others/Rollup使用.html" class="sidebar-link">Rollup使用</a></li><li><a href="/docs/others/Nginx配置.html" class="sidebar-link">Nginx基础配置与操作</a></li><li><a href="/docs/others/环境&amp;软件安装.html" class="sidebar-link">环境&amp;软件安装</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lit-框架创建-web-components"><a href="#lit-框架创建-web-components" class="header-anchor">#</a> Lit 框架创建 Web Components</h1> <p>Lit 是一个 Web 工具库，它提供了一种简单的方式来创建可重用的 Web Components 标准组件或叫<strong>自定义元素</strong>。</p> <p>该框架包含多个常用类和工具函数（TS下还有一些简写的装饰器语法）：</p> <ul><li><code>LitElement</code>：一个基类，用于创建自定义 Web Components，其是<code>ReactiveElement</code>(实现了响应式属性)的子类，而<code>ReactiveElement</code>又是原生<code>HTMLElement</code>的子类</li> <li><code>html</code>：一个模板字符串标签函数，用于在组件中创建 HTML 模板</li> <li><code>css</code>：一个模板字符串标签函数，用于在组件中创建 CSS 样式</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <ul><li>对于 DOM 对象上的 prop 我们称为属性；</li> <li>对于元素 tag 标签上的 attr 我们称为特性。</li></ul> <p>也即是 jQuery 对象中 <code>prop()</code> 与 <code>attr()</code> 方法的区别。</p></div> <h2 id="定义元素"><a href="#定义元素" class="header-anchor">#</a> 定义元素</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 组件内容 */</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义元素（此为原生API）</span>
customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">,</span> MyElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="渲染内容"><a href="#渲染内容" class="header-anchor">#</a> 渲染内容</h2> <p>为 Lit 组件定义一个<code>render()</code>方法，该方法返回一个 HTML 模板，该模板将被插入到组件的 shadow DOM 中，大多情况下我们使用标签函数<code>html</code>处理该模板。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 字符串模板中可以正常插入JS表达式（即${}插入）</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;Hello from my template.&lt;/p&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
customElements<span class="token punctuation">.</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'my-element'</span><span class="token punctuation">,</span> MyElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="响应式属性"><a href="#响应式属性" class="header-anchor">#</a> 响应式属性</h2> <p>Lit 中的响应式属性是通过声明静态属性<code>properties</code>对象实现的，它允许我们定义一个属性，当属性值发生变化时，Lit 会自动重新渲染组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token comment">// 通过静态属性来定义，静态属性只能在类对象上访问(MyElement.xxx)，而不是实例对象上访问</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 每个属性都包含一些可配置项，若不配置则应保留空配置对象(表示都使用默认值)</span>
    <span class="token comment">//! 此为公共响应式属性，原则上应该响应用户的输入而变化，组件内不应更改</span>
    name<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> String <span class="token punctuation">}</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number <span class="token punctuation">}</span><span class="token punctuation">,</span>
    sex<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">//! state 设为 true 表示是内部响应式状态属性，建议以下划线`_`开头以区别于公共属性，用于组件内使用</span>
    _counter<span class="token operator">:</span> <span class="token punctuation">{</span> state<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在构造函数中初始化相关属性值，注意这里不是通过 this.properties 访问</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//! 不应该使用类字段语法方式声明属性，因为该方式声明的属性不是响应式的，除非本意就是不参与响应式变化</span>
  <span class="token comment">// foo = 'default';</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每个属性都包含一些可配置项，<strong>若不配置则应保留空配置对象</strong>(表示都使用默认值)，配置项包含：</p> <ul><li><code>attribute</code>: 布尔值或字符串，默认 true，表示是否将属性映射到元素标签的 attr 上（即通过 attr 来传值），若为false，则不会进行映射关联，同时会忽略<code>converter</code>、<code>reflect</code>和<code>type</code>选项，若为字符串则表示显式指定的 attr 名字（否则默认为该 prop 的全小写形式）；</li> <li><code>converter</code>: 对象或函数，默认内置转换器，用于 DOM 的 prop 与标签的 attr 间关系转换；</li> <li><code>hasChanged</code>: 函数，每当设置属性时调用，用于判断属性值是否发生变化，不指定则默认采用严格不等式进行比较(即<code>!==</code>)；</li> <li><code>noAccessor</code>: 布尔值，默认 false，表示是否禁用属性的访问器，若为 true，则属性将不会有 getter 和 setter，且无法在组件中直接访问；</li> <li><code>reflect</code>: 布尔值，默认 false，表示是否将 prop 属性值的变更同步映射到元素标签的 attr 上，可用于数据的双向绑定；</li> <li><code>state</code>: 布尔值，默认 false，表示是否将属性标记为内部状态属性，若为 true，则不会为该属性生成元素标签对应的 attribute，且不会触发属性变化事件，此时唯一可指定的额外选项只有<code>hasChange</code>，但响应式还是具备的；</li> <li><code>type</code>: 将字符串类型的 attr 特性转换为 prop 属性时应该转换为的数据类型，如果设置了<code>converter</code>选项，则会将该字段的值传给该转换器（意味着我们可以自定义一些<code>type</code>类型），若未指定<code>type</code>则默认转换器会将其视为 String 类型；</li> <li><code>useDefault</code>: 布尔值，默认 false，表示是否使用默认值，设置为 true 可在<code>reflect</code>设置为 true 时防止初始 attr 值映射到 prop 上，并在移除相应 attr 时将 prop 重置为构造函数声明时的默认值，但若非原始 Object/Array 属性，最好避免设置为 true，因为可能已不是真正的原始默认值；</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>默认情况下，Lit 将 prop 映射为元素标签的 attr 时，其映射的 attr 名为 prop 的全小写形式，即<code>myName</code>property 会被映射为的 attr 为<code>myname</code>。</p> <p>若想自定义对应的 attr 名字，可将上面的<code>attribute</code>配置项指定为字符串即为定义的的特性名，比如多个词的属性时我们想使用更符合标签特性命名规范的烤串格式，可将前面的属性配置为<code>{ attribute: 'my-name' }</code>，此时<code>myName</code>property就将映射为<code>my-name</code>attribute。</p></div> <p>property更改可能会触发响应式更新周期，从而导致组件重新渲染其模板，其触发顺序是：</p> <ol><li>该属性的 setter 函数调用；</li> <li>setter 函数调用组件的<code>requestUpdate()</code>方法；</li> <li>属性的新旧值比较；
<ul><li>默认情况下，Lit 使用严格不等式<code>!==</code>来比较属性值是否发生变化；</li> <li>若该属性指定了<code>hasChanged</code>函数，则会将属性的旧值和新值作为参数传递给该函数以应用自定义单的比较逻辑，该函数应该返回一个布尔值，表示属性值是否发生变化；</li></ul></li> <li>若属性值发生变化，将异步安排更新，若已安排了更新，则仅执行最后一次更新；</li> <li>调用组件的<code>update()</code>方法，将更改后的属性映射到 attr 中，并重新渲染组件 HTML 模板；</li></ol> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <ol><li>上面配置项中<code>attribute</code>字段虽然会在 HTML 标签上创建对应的 attribute 以用于传值(并不代表 HTML 标签上一定会初始化存在该 attr，只是说此时就可以通过 attr 传值了)，但此时数据流是单向的，类似 Vue 中的<code>props</code>数据，但不同的是 Lit 中这些 prop 是可以更改，且更改后会反应到UI模板上，而不只是从 attr 上同步过来，若要体现该<code>attribute</code>的双向数据流绑定，则需要启用<code>reflect</code>选项，此时 prop 的变更才会同步到 attr 上；
<ul><li>需要注意的是这些配置都是符合HTML元素的标准表现的，而不是主流的 Vue/React 等组件的表现，HTML 元素中 attr 的变化基本都会同步到 DOM 的 prop 上，而 prop 也可以单独修改，但 prop 的修改并不一定都会同步到元素的 attr 上。比如元素的<code>id</code>，HTML 的 attr 和 DOM 的 prop 更改都会互相同步，而 input 元素的<code>value</code>就不一样了，attr 的变化会反应到 prop 上，但 prop 的变化并不会反应到 attr 上。</li></ul></li> <li>若改变的是一个对象或数组等引用类型的值，则不会触发更新，除非直接替换整个对象或数组，原因同 Vue2 中的响应式原理（只不过 Vue2 改写了数组的部分方法使得其可触发响应）。</li></ol> <p>对于这类数据先引起组件模板更新可借鉴下面的处理方案。</p></div> <h3 id="变更对象和数组属性"><a href="#变更对象和数组属性" class="header-anchor">#</a> 变更对象和数组属性</h3> <p>要使这类值的属性响应式更新，可采用以下方案之一：</p> <ul><li><strong>不可变数据模式</strong>：将这类数据视为不可变的，不能修改，只能产生新的，即利用旧数据生成一个新的数据来替换原来的数据，简单的数据可使用原生API解构扩展及遍历等方式生成新值，对于复杂数据结构可以使用想 <a href="https://immerjs.github.io/immer/zh-CN/" target="_blank" rel="noopener noreferrer">Immer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这样的工具库来处理。</li> <li><strong>手动触发更新</strong>：直接在原数据上进行更改操作，然后调用<code>requestUpdate()</code>方法手动触发更新，当不带参数调用该方法时，该方法会安排一次更新，但不会调用<code>hasChanged</code>来判断是否值发生了变化，而是强制更新，例如：<div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 响应式属性</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Object <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">updateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接修改原数据</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
    <span class="token comment">// 手动触发更新</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requestUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;p&gt;Name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;
      &lt;p&gt;Age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/p&gt;
      &lt;button @click=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>updateData<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;&gt;Update Age&lt;/button&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>但需要注意，<code>requestUpdate()</code>只会导致当前组件更新，如果组件内有将上面的<code>data</code>传给其子组件，对子组件来说数据仍是未变化的(引用未变)，也就不会触发子组件的模板更新，要触发更新就需要每个用到该<code>data</code>数据的组件都调用<code>requestUpdate()</code>。</p></div></li></ul> <h3 id="属性数据转换"><a href="#属性数据转换" class="header-anchor">#</a> 属性数据转换</h3> <p>Lit 中的默认转换器可处理<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>和<code>Object</code>类型的 prop 数据，若需要处理其他类型的数据，则可通过<code>converter</code>选项来指定一个转换器函数。使用默认转换器的方式很简单，直接在属性声明中指定<code>type</code>选项即可，若未显式指定也未通过<code>converter</code>选项自定义转换器，则默认是<code>String</code>类型。</p> <p>若设有<code>type</code>字段，则 Lit 会将 attr 的字符串值转换为指定的<code>type</code>类型的值赋给对应的 property，注意对于欲解析为引用数据类型的字符串，Lit 是直接使用的<code>JSON.parse()</code>方法转换，所以对于 JSON 字符串必须符合 JSON 规范，否则会报错。</p> <p>在 prop 值转为相应的 attr 字符串值中，若 prop 的值为<code>null</code>或<code>undefined</code>，则 Lit 会移除元素标签上对应的 attribute（对于<code>type</code>为<code>Boolean</code>的 property，只要其值为假就会移除 attribute），而引用类型数据在转为字符串值时，Lit 直接使用<code>JSON.stringify()</code>方法转换，所以对于非标准 JSON 字段或数据在转换中可能就会丢失。</p> <h4 id="自定义属性数据转换器"><a href="#自定义属性数据转换器" class="header-anchor">#</a> 自定义属性数据转换器</h4> <p>前面有提到可以通过配置<code>converter</code>选项来自定义转换器，该选项可以是一个<strong>对象或函数</strong>。</p> <p>当<code>converter</code>为对象时，其包含以下两个方法：</p> <ul><li><code>fromAttribute(value, type)</code>：该方法用于将 attr 字符串值<code>value</code>转换为指定的<code>type</code>类型 prop 值，并应该返回转换后的值，<code>type</code>可以是我们自定义的类型，比如<code>Function</code>；</li> <li><code>toAttribute(value, type)</code>：该方法用于将 prop <code>type</code>类型值<code>value</code>转换为 attr 字符串值，并应该返回转换后的值，若返回<code>null</code>或<code>undefined</code>则会从元素标签上移除该对应的 attribute。这里<code>type</code>参数可用于自行进一步验证<code>value</code>值合法性？</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    myProp<span class="token operator">:</span> <span class="token punctuation">{</span>
      converter<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">fromAttribute</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将字符串的 value 转换为 type 类型数据并返回用于映射到 prop 上</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">toAttribute</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将 type 类型的 value 转换为字符串值并返回用于映射到 attr 上</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当<code>converter</code>为函数时，其就表示<code>fromAttribute</code>函数，等同于省略<code>toAttribute</code>选项的对象简写形式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    myProp<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">converter</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 等同于 { converter: { fromAttribute: ()=&gt;{} }</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>若<code>converter</code>使用函数值，或省略<code>toAttribute</code>选项的对象值，则 Lit 使用内置的默认转换器来将 prop 值映射到 attr 上。</p> <p>个人认为这对于单向数据流的 prop 没有影响，因为我们只需要单向通过 attr 传递值到内部 prop 使用，并不更改 prop 又映射到 attr 上去，就像 vue 中的<code>props</code>与<code>v-model</code>，<code>props</code>用于单向传值，而<code>v-model</code>用于双向绑定，这可以通过配置 prop 的<code>reflect</code>选项来启用双向绑定。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>对于布尔类型的 attribute，在定义其对应的 prop 时默认值必须为<code>false</code>，若其默认值为<code>true</code>则无法通过标签将其设置为 false，因为布尔型 attr 无论是否有值，只要 attr 存在就等同于<code>true</code>。这是 Web 平台中 attr 的标准行为。</p> <p>若该标准特性不符合组件使用场景，可以使用以下方案之一改造组件：</p> <ul><li>更改 attr 为其反义名字，使其默认值为<code>false</code>，例如，HTML表单元素使用 <code>disabled</code> 属性（默认值为 <code>false</code>），而不是 <code>enabled</code>；</li> <li>使用字符串类型或数值类型的 attribute，而不是布尔类型。</li></ul></div> <h3 id="attribute反射-双向绑定"><a href="#attribute反射-双向绑定" class="header-anchor">#</a> attribute反射(双向绑定)</h3> <p>前面提到<code>attribute</code>选项只是单向映射-<strong>attr2prop</strong>，prop 虽可变化并响应内部DOM，但不会同步到 attr 上，若要实现双向绑定，则可通过配置<code>reflect</code>选项来启用将 prop 的变更同步到 attr 上-<strong>prop2attr</strong>（通过 Lit 的默认转换器或自定义的转换器）。</p> <p>单从数据交互来说，用到<code>reflect</code>选项的地方应该比较少，因为 Lit 中 attr2prop 是响应式的可触发渲染更新，而 prop 的单独修改也是响应式的可触发渲染更新，似乎<code>reflect</code>的 prop2attr 并没有必要。但在 CSS 的角度来看就不一样了，因为 attr 的变化体现在 HTML 标签上，对于 attr 的不同值可枚举的话用于 CSS 中的属性状态匹配来设置不同样式是很有用的，另一方面就是也可以适应当下 Vue 等框架组件中的<code>v-model</code>模式，方便组件外部使用同步更改的数据。</p> <p><code>reflect</code>为<code>true</code>的情况下，将<code>useDefault</code>设置为<code>true</code>会阻止 prop 的默认值在初始时同步到其相应的 attr 上，而后所有后续更改都会同步，如果该 attr 被移除，该 prop 将重置为其默认值。该效果与像元素<code>id</code>这类 attr 的行为一致，元素的<code>id</code> prop 默认值为<code>''</code>（空字符串），并且最初 HTML 上没有<code>id</code> attr，但如果设置了<code>id</code> prop（即使设置为空字符串），相应的<code>id</code> attr 也会在 HTML 上体现出来，如果移除 HTML 上<code>id</code> attr，DOM 的<code>id</code> prop 会被重置为初始值<code>''</code>。</p> <p>为确保元素按预期运行并表现良好，在应用<code>reflect</code>时尽量遵循以下最佳实践：</p> <ul><li>HTML 的 attr 应作为用户的输入来源，而不应该由元素自身控制，谨慎使用 prop2attr，尽可能考虑使用<code>:state()</code>伪类和可访问性对象模型(无障碍属性)；</li> <li>反射属性通常也应设置<code>useDefault: true</code>，因为可以防止元素自动生成用户未设置的属性，并有助于匹配预期的平台行为；</li> <li>不建议反射数据为引用类型；</li> <li>这些属性配置项并不会自行更改分配给响应式属性的值，有时原生元素会将 prop 限制为某些有效值，若为 prop 分配了无效值，该 prop 将改为设置为默认值。<code>useDefault: true</code>并不会这样做，它仅在移除 attr 时恢复默认值。如果想在 prop 赋值时更改 prop 值，可以定义并装饰一个自定义 prop 设置器 setter。</li></ul> <h3 id="自定义property访问器"><a href="#自定义property访问器" class="header-anchor">#</a> 自定义property访问器</h3> <p>默认情况下，<code>LitElement</code>类会自动为每个响应式属性定义一对 getter/setter（都属于访问器 accessor），这些 getter 和 setter 用于获取和设置属性的值，其中 setter 会自动调用<code>requestUpdate()</code>，若此时更新还未开始则立即启动更新，已开始就等下一轮。</p> <p>自定义属性的 getter/setter：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  _prop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">set</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_prop<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_prop <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token comment">// 手动调用更新，两个可选参数分别表示更新的 property，和该 property 的上一个值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requestUpdate</span><span class="token punctuation">(</span><span class="token string">'prop'</span><span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">get</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_prop<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大多情况下，我们无需自定义属性访问器，只有极少数需要同步验证用户设置的任何值时可能会用到自定义设置器。若要在值更新前后做其他事，建议使用生命周期函数，比如以下两个：</p> <ul><li><code>willUpdate(changedProperties)</code>：该函数在更新前调用，<code>changedProperties</code>参数为一个<code>Map</code>对象，包含即将更改的 prop 名称和其旧值键值对；</li> <li><code>updated(changedProperties)</code>：该函数在更新后调用，参数同上。</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>当子类中存在父类已定义的响应式属性(相当于重复声明)，若未自定义访问器，Lit 默认仍会生成访问器从而覆盖父类该属性的访问器（相当于子类重新定义了，跟父类该属性的配置无关了），所以一般来说子类对该属性无特殊需求就不应该重复声明。若子类只是想更改父类上该已有属性的配置项以便适应子类的特殊需求，但并不想因此 Lit 又生成访问器覆盖父类的访问器，则可以在子类中该属性上配置<code>{ noAccessor: true }</code>来阻止 Lit 为子类该属性重新生成访问器，若要自定义访问器则无需设置改配置项。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 继承自某父类的子类中更改父类同名属性 myProp 的 type（假设父类中为 Boolean）</span>
<span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
  myProp<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> Number<span class="token punctuation">,</span> noAccessor<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <h3 id="自定义属性变更检测"><a href="#自定义属性变更检测" class="header-anchor">#</a> 自定义属性变更检测</h3> <p>也即是前面有提到的<code>hasChanged</code>配置项，自定义函数检测判断值是否变更，返回布尔值，若返回<code>true</code>有变更则走更新流程(响应更新的生命周期)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 设置为仅奇数认为有变化</span>
      <span class="token function">hasChanged</span><span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> hasChanged <span class="token operator">=</span> newVal <span class="token operator">!==</span> oldVal <span class="token operator">&amp;&amp;</span> newVal <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>oldVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hasChanged<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hasChanged<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="css-样式"><a href="#css-样式" class="header-anchor">#</a> CSS 样式</h2> <ul><li>编程式：通过在类中声明静态属性<code>styles</code>，并赋值为通过<code>css</code>字符串标签函数处理的 CSS 代码，这样添加的 CSS 将作用到组件内的 Shadow DOM 上（前面<code>render</code>中声明的 HTML 模板，这样定义的 HTML 和 CSS 都将渲染在组件内的 shadowRoot 根节点中，不会影响外部结构和样式）；</li> <li>声明式：通过在 HTML 模板中添加<code>&lt;style&gt;</code>标签创建内联样式，或使用<code>&lt;link&gt;</code>标签链接外部样式**(不推荐外联样式)**；</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>编程式与声明式创建的样式虽然都有效，但两者样式的存在位置是不是一样的，编程式的最终会应用到 <strong>shadowRoot</strong>，在浏览器开发者工具的 shadow tree 中是看不到的，而声明式的<code>&lt;style&gt;</code>标签就跟 shadow DOM 中的其他 HTML 标签一样是在 shadow tree 中可见的。</p></div> <p>编程式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> css<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    :host {
      color: red;
    }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;我是红色的&lt;/p&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这样添加的样式为静态样式，即不会根据组件外部进行动态处理的样式，适用于所有组件实例，大多情况下是添加样式的最佳方式。静态属性<code>style</code>的值可以是一个带<code>css</code>标签的模板字面量，也可以是这样的一组字面量<code>[css`xxx`, css`xxx`]</code>。</p></div> <p>声明式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;style&gt;
        :host {
          color: red;
        }
      &lt;/style&gt;
      &lt;p&gt;我是红色的&lt;/p&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>静态样式中也可以使用表达式，只要是同步操作就可以，但为防止恶意代码，Lit 对字符串中的表达式进行了限制，要求这些表达式本身也必须是带<code>css</code>标签的字符串或数字，若特殊情况必须使用非<code>css</code>标签字面量的表达式，并且我们可以确定该表达式来源可信，比如自己代码定义的常量，那么也可以使用<code>unsafeCSS()</code>函数包装该表达式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> primaryColor <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">blue</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> dangerColor <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">red</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

  <span class="token comment">// 由 css 标记的表达式可直接使用，否则需要使用 unsafeCSS 函数包裹</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    :host { color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>primaryColor<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; }
    .danger { color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">unsafeCSS</span><span class="token punctuation">(</span>dangerColor<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>上面在静态样式中使用表达式的场景来看，似乎比较适合定义一些样式常量，但若是针对定制 UI 主题，使用 CSS 变量更加合适。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>虽然声明式 CSS 中也可以使用表达式，但存在一些重要的限制和性能问题，故不推荐使用。</p></div> <div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>由于 web components 所有内容都是在 JS 中定义的，而 CSS 中使用的<code>Unicode</code>转义字符格式为反斜杠<code>\</code>加四或六位十六进制数字(如项目符号字符<code>\2022</code>)，格式与 JS 中废弃的八进制转义格式类似，故直接在 JS 中使用会报错，为此有两种解决方案：</p> <ol><li>使用两个反斜杠，如：<code>\\2022</code>；</li> <li>使用<code>\u</code>开头，如：<code>\u2022</code>。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  div::before {
    content: '\u2022';
  }
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre></div></div> <h3 id="从父类继承样式"><a href="#从父类继承样式" class="header-anchor">#</a> 从父类继承样式</h3> <p>子类继承父类时包括<code>styles</code>这些静态属性本就会被继承，若不需要做样式修改就无需对样式进行声明，若子类也声明了<code>styles</code>静态属性，那就是对父类的重写覆盖，即使声明后赋了空值，此时相当于丢弃了父类的样式。若还要使用父类中的样式，但子类中又需要覆盖或定义一部分自己的样式，那就需要将父类的样式手动引用到当前子类中，此时其实不能称为继承了，而是复用（<strong>注意顺序，复用父类的应该在前面，自定义的应该后</strong>）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> MyParentElement <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-parent-element.js'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">MyParentElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> <span class="token punctuation">[</span>
    MyParentElement<span class="token punctuation">.</span>styles<span class="token punctuation">,</span> <span class="token comment">// 引用父类的静态样式</span>
    <span class="token comment">// 覆盖或增加一部分自己的特殊样式</span>
    css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      div {
        color: red;
      }
    </span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="共享样式"><a href="#共享样式" class="header-anchor">#</a> 共享样式</h3> <p>这里的共享样式并非常规开发中的全局样式，一份就作用于所有组件，而是指多个组件都可以引用到自己内部的共性样式，实际每个组件都会生成一份，只是来源于同一处。操作方式也就是在一个单独的 JS 模块中声明带<code>css</code>标签的样式并导出供其他需要的组件导入放在自己的静态<code>styles</code>中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// shared-styles.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> resetStyles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  p { margin: 0; }
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>

<span class="token comment">// 在需要引用的组件中：</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> resetStyles <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./shared-styles.js'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> <span class="token punctuation">[</span>
    sharedStyles<span class="token punctuation">,</span>
    css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      p { color: blue; }
    </span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="动态样式class和style"><a href="#动态样式class和style" class="header-anchor">#</a> 动态样式class和style</h3> <p>这里指的是在组件内元素上动态切换<code>class</code>和<code>style</code>行内样式，需要用到 Lit 提供的额外两个指令方法--<code>classMap()</code>和<code>styleMap()</code>，可用于处理类似 Vue 中的元素<code>class</code>和<code>style</code>属性的对象结构值。</p> <p>用法示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> LitElement<span class="token punctuation">,</span> html<span class="token punctuation">,</span> css <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> classMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit/directives/class-map.js'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> styleMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lit/directives/style-map.js'</span><span class="token punctuation">;</span>
​
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MyElement</span> <span class="token keyword">extends</span> <span class="token class-name">LitElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> properties <span class="token operator">=</span> <span class="token punctuation">{</span>
    classes<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    styles<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> styles <span class="token operator">=</span> css<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    .someclass { border: 1px solid red; padding: 4px; }
    .anotherclass { background-color: navy; }
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
​
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>classes <span class="token operator">=</span> <span class="token punctuation">{</span> someclass<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> anotherclass<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>styles <span class="token operator">=</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'lightgreen'</span><span class="token punctuation">,</span> fontFamily<span class="token operator">:</span> <span class="token string">'Roboto'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;div class=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">classMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>classes<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> style=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">styleMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>styles<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;
        Some content
      &lt;/div&gt;
    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="主题样式风格"><a href="#主题样式风格" class="header-anchor">#</a> 主题样式风格</h3> <p>通过 CSS 变量来定义主题风格，对外暴露统一修改方案。</p> <h2 id="组件生命周期"><a href="#组件生命周期" class="header-anchor">#</a> 组件生命周期</h2> <h3 id="标准自定义元素生命周期"><a href="#标准自定义元素生命周期" class="header-anchor">#</a> 标准自定义元素生命周期</h3> <p>此类生命周期指的是 web 标准中定义 web components 的 class 类中规范的 5 个生命周期方法（Lit 中当然也可用）。按触发顺序分别为：</p> <ol><li><code>constructor()</code>：构造函数，在元素被<strong>创建或升级时</strong>调用（升级指的是自定义元素已先在 DOM 中存在，而元素的定义在之后才加载的情况，也就是在 HTML5 中未知元素在未定义前会被当做普通行内元素处理，而在其定义被加载解析后就会升级为自定义元素）；
<ul><li>Lit 会在此阶段调用<code>requestUpdate()</code>请求异步更新，因此在 Lit 组件升级时，其会立即更新绑定标签上相关已设置内容；</li> <li>应在此方法中设置 prop 的默认值</li></ul></li> <li><code>connectedCallback()</code>：连接回调，在元素被添加到文档的 DOM 中时调用，在该函数中应设置仅在元素连接到文档时才执行的任务（类似 Vue 中 mounted 钩子），常见的是在外部对象上添加事件监听器（如 window 或 document 上），并在元素断开连接时撤销这些任务（类似 Vue 中 beforeUnmount 钩子做的事）；
<ul><li>Lit 在元素连接后启动第一个元素更新周期。为渲染做准备时，Lit 还会确保创建 <code>renderRoot</code>（通常是其 shadowRoot），一旦某个元素至少与文档连接过一次，无论该元素的连接状态如何，组件更新都将继续进行；</li> <li>Lit 中使用该钩子时，还应该调用<code>super.connectedCallback()</code>以使用父类上的默认行为</li></ul></li> <li><code>disconnectedCallback</code>：断开连接回调，为上面连接回调的对立面，类似 Vue 中的 beforeUnmount 钩子（不是 unmounted，因为 unmounted 是已销毁完成），应在该回调中撤销上面创建的任务（<strong>对于事件监听器，移除创建的外部事件监听器即可，对于组件内自身 DOM 上的事件监听器虚无移除，内部的不会产生影响</strong>）；
<ul><li>Lit 会在此阶段暂停响应式更新周期（Lit 独有，后面介绍），而当元素重新连接时又恢复；</li> <li>同样，Lit 中使用该钩子时，也应该调用<code>super.disconnectedCallback()</code>以使用父类上的默认行为</li></ul></li> <li><code>attributeChangedCallback()</code>：属性更改回调，当元素的某个<code>observedAttributes</code>被观察属性发生变化时调用；
<ul><li>Lit 使用此回调将 attr 的更改同步到响应式 prop。Lit 还会自动设置元素的 <code>observedAttributes</code> 数组，以匹配组件的响应式属性列表；</li> <li>由于 Lit 内部的响应式封装，很少需要手动调用这个方法</li></ul></li> <li><code>adoptedCallback()</code>：当组件移动到新文档时调用，很少使用，且该钩子没有 Polyfill 实现。
<ul><li>Lit 对此回调没有默认行为</li></ul></li></ol> <h3 id="响应式更新生命周期"><a href="#响应式更新生命周期" class="header-anchor">#</a> 响应式更新生命周期</h3> <p>这部分的生命周期钩子是 Lit 组件专有的，当响应式属性发生变化或显式调用 <code>requestUpdate()</code> 方法时，会触发响应式更新周期。Lit 异步执行更新，因此属性变化会被批量处理 —— 如果在请求更新后但更新开始前有更多属性发生变化，所有这些变化都会在同一次更新中被捕获。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/js/WebComponents.html" class="prev">
        Web Components
      </a></span> <span class="next"><a href="/docs/js/File文件API.html">
        File文件API
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/docs/assets/js/app.08fe61ab.js" defer></script><script src="/docs/assets/js/2.7cd822c1.js" defer></script><script src="/docs/assets/js/33.0386436d.js" defer></script>
  </body>
</html>
